package main

import (
	"bytes"
	_ "context"
	"database/sql"
	"encoding/json"
	"github.com/knieriem/odf/ods"
	"path/filepath"
	"plugin"
	"reflect"
	"strconv"
	"strings"
	txtTpl "text/template"
)

/*
Действия
каждый Действия должен возвращать самостоятельно ответ пользователю
client.Message<-&Сообщение{}

Можно считать что каждое действие атомарно, и должно само позаботиться о доставке ответа клиенту

*/
var Действия map[string]interface{}

func (client *Client) ИО(вопрос Сообщение) {
	Инфо("server.Clients  %+v", server.Clients)
	//for login, данные := range server.Clients{
	//	Инфо(" login %+v  %+v", login, данные.Ws.RemoteAddr())
	//}
	Инфо(">>> ИО IOHandler \n Входящее Сообщение %+v \n client.Ws.RemoteAddr %+v <<<<<< \n", вопрос, client.Ws.RemoteAddr())

	if вопрос.Текст != "" {
		client.ВопросИО(&вопрос)
	}

	if вопрос.Выполнить.Action != "" || вопрос.Выполнить.Действие != nil {

		// алгоритм Все команды боту на выполнения обрабатываемыые через вопрос.Выполнить.Действие Должны сами возвращать ответ клиенту

		if Действия[вопрос.Выполнить.Action] != nil {
			Действия[вопрос.Выполнить.Action].(func(*Client, Сообщение))(client, вопрос)
		}

		if вопрос.Выполнить.Действие != nil {
			for НазваниеДействия, _ := range вопрос.Выполнить.Действие {
				Инфо("НазваниеДействия %+v\n", НазваниеДействия)
				//Инфо("Действия[НазваниеДействия] %+v\n", Действия[НазваниеДействия])
				//Инфо("Действия %+v\n", Действия)
				/*
				   алгоритм  Этот алгоритм нужен будет когда я попытаюсь организовать диалогового бота
				   		Нужно пройти по ключам карты Action
				   		 и проверит не содержит ли какое либо слово действие из action
				   		 но это может быть накаладно если слов в запросе много,
				   		 поэтому будет смотреть первое и второе слово, при это назначим слова котрые будут пропускать,
				   		например Ио, пожалуйста,спасибо и другие кеоторе не несут полноценного лексического значения,
				   		(а добавляют только какие-то оттенки в высказывание, не являются членами предложения.
				   				Их относят к междометиям.  )

				   				ИгнорируемыеСлова := []stvscode ring{"ио", "пожалуйста", "спасибо"}

				   				//СловарьИзОбращенияКИО := strings.Split(НазваниеДействия, " ")
				   				var ЧистоеОбращение string
				   				for _, Слово := range ИгнорируемыеСлова {
				   					ЧистоеОбращение =strings.Replace(НазваниеДействия, Слово, "", -1)
				   				}

				   				Действие := strings.Split(ЧистоеОбращение, " ")[0]
				   				if Действия[Действие] != nil {
				   					Действия[Действие].(func(*Client, Сообщение, map[string]interface{}))(client, вопрос,
				   						ПараметрыДействия)
				   				}

				*/

				if Действия[НазваниеДействия] != nil {
					Действия[НазваниеДействия].(func(*Client, Сообщение))(client, вопрос)
				} else {
					Инфо("НазваниеДействия %+v  вопрос.Текст %+v\n", НазваниеДействия, вопрос.Текст)
					// Попробуем проверить есть ли в диалоги_ио активирующее_собщение с
					if вопрос.Текст == "" {
						вопрос.Текст = НазваниеДействия
						Инфо("НазваниеДействия %+v\n", НазваниеДействия)
						Инфо("вопрос.Текст %+v\n", вопрос.Текст)
						// если в вопрос.Текст есть сообщение то оно должно было выполниться в самом начале, этот блок выполняется чтолько если в вопрос.Текст пусто
						client.ВопросИО(&вопрос)
					} else {
						if вопрос.Текст != НазваниеДействия {
							client.ВопросИО(&вопрос)
						}

					}
				}
			}
		}
	} else {
		/*
			Пробеум загрузить плагин и выполнить действие из него
		*/
		if вопрос.Выполнить.Action != "" {
			client.Plugins(вопрос)
		}
	}

	if вопрос.Выполнить.Cmd != "" || вопрос.Выполнить.Комманду != "" {
		// Функция сама возвращает ответ клиенту
		Инфо("вопрос.Выполнить.Arg.Login %+v\n", вопрос.Выполнить.Arg.Login)
		//client.ВыполнитьНесколькоКоммандПоSSH(вопрос)
		client.ВыполнитьКоммандуПоSSH(вопрос)

	}

	if вопрос.Выполнить.Skill != 0 || (вопрос.Выполнить.Навык.String() != "" && вопрос.Выполнить.Навык.String() != "0") {
		client.ЗапуститьНавык(вопрос)
	}
	//Инфо("\n\n  Login %+v client.АктивныеДиалоги final 1 %+v \n",client.Login, client.АктивныеДиалоги)
	//client.АктивныеДиалоги = []map[string]interface{}{}

}

func ActionsInit() {

	Действия = map[string]interface{}{
		"ПолучитьЛогЧата":    (*Client).ПолучитьЛогПереписки,
		"getIoMenu":          (*Client).ПолучитьМенюБота,
		"СоздатьРабочийСтол": (*Client).СоздатьРабочийСтол,

		"ОбработатьВУЦ":              ОбработатьВУЦ,
		"СохранитьДанныеБухгалтерии": СохранитьДанныеБухгалтерии,
		"СохранитьДанныеВEXCEL":      СохранитьДанныеВEXCEL,

		"Детализация": Детализация,

		"СохранитьВБД":                      СохранитьВБД,
		"ВыполнитьСкрипт":                   ВыполнитьСкрипт,
		"ВыполнитьСкриптДляКаждогоЗначения": ВыполнитьСкриптДляКаждогоЗначения,

		"СобратьИВыполнитьСпецФильтры": СобратьИВыполнитьСпецФильтры,
		"СобратьСтатДанные":            СобратьСтатДанные,

		"ОбработатьСтатОтчёт": ОбработатьСтатОтчёт,

		"collectData":        (*Client).СобратьДанные, // Собирает данные из аис
		"ДобавитьСпецФильтр": (*Client).ДобавитьСпецФильтр,
		"ИзменитьСпецФильтр": (*Client).ИзменитьСпецФильтр,
		"УдалитьСпецФильтр":  (*Client).УдалитьСпецФильтр,
		"СобратьДанныеИзРБД": (*Client).СобратьДанныеИзРБД,

		"ЗагрузитьДетализацию": (*Client).ЗагрузитьДетализацию,

		"СобратьДанныеИзАИС": (*Client).СобратьДанныеИзАИС,

		"ЗагрузитьКэшСтатистикиРБД": (*Client).ЗагрузитьКэшСтатистикиРБД,

		"СинхронизироватьДанныеПользователей": (*Client).СинхронизироватьДанныеПользователей,

		"СобратьДанныеИзОСПВТаблицу": (*Client).СобратьДанныеИзОСПВТаблицу,
		"СобратьДанныеИзОСПВEXCEL":   (*Client).СобратьДанныеИзОСПВEXCEL,
		"GetData":                (*Client).ЗагрузитьДанные,
		"SSHConnect":             (*Client).SSHConnect,
		"CloseSSH":               (*Client).СloseSSH,
		"CreateSkillName":        (*Client).CreateSkillName,
		"CreateSkillDescription": (*Client).CreateSkillDescription,
		"CreateSkillCmd":         (*Client).CreateSkillCmd,
		"AddSkillTags":           (*Client).AddSkillTags,
		"AllowSelfUse":           (*Client).AllowSelfUse,
		"AddProblemDescription":  (*Client).AddProblemDescription,
		"ShowNewSkill":           (*Client).ShowNewSkill,
		//"ИзменитьНавык":(*Client).ИзменитьНавык,
		"ПоказатьНавык":            (*Client).ПоказатьНавык,
		"ПоказатьНавыки":           (*Client).ПоказатьНавыки,
		"РедакторНавыка":           (*Client).РедакторНавыка,
		"СохранитьИзмененияНавыка": (*Client).СохранитьИзмененияНавыка,
		"НовыйНавык":               (*Client).НовыйНавык,
		"СоздатьНавык":             (*Client).СоздатьНавык,
		"УдалитьНавык":             (*Client).УдалитьНавык,
		"ПроверитьЛогин":           (*Client).ПроверитьЛогин,
		"Авторизация":              (*Client).Авторизация,
		"СоздатьЗаявку":            (*Client).СоздатьЗаявку,
		"ПоказатьСписокЗаявок":     (*Client).ПоказатьСписокЗаявок,

		//"ПоказатьБазуЗнаний":(*Client).ПоказатьБазуЗнаний,
		"ВыполнитьSQLвАИС": (*Client).ВыполнитьSQLвАИС,
		//"загрузить патч":(*Client).СохранитьФайл,
		"ОбновитьДанныеПоПК":            (*Client).ОбновитьДанныеПоПК,
		"СинхронихироватьКлючи":         (*Client).СинхронихироватьКлючи,
		"СинхронихироватьДатыКриптоПро": (*Client).СинхронихироватьДатыКриптоПро,
		"НайтиИРАспарсить":              (*Client).НайтиИРАспарсить,
		//"Найти":(*Client).Найти,
		//"Найди":(*Client).Найти,
		//"Поиск":(*Client).Найти,
		//"EndSkillCreate":(*Client).EndSkillCreate,
		//"SkillTags":(*Client).SkillTags,
		//"GetData":DataCollector,
		//"CollectData": DataCollector,
	}
}

func Plugin(client *Client, mes Сообщение) {
	//mes.Выполнить.Action
	DataCollector, err := plugin.Open("./plugins/DataCollector.so")
	if err != nil {
		Инфо("Ошибка загрузки плагина DataCollector %+v\n", err)
	}

	ActionFunction, err := DataCollector.Lookup(mes.Выполнить.Action)
	if err != nil {
		Инфо("err	 %+v\n", err)
	}
	ActionFunction.(func(*Client, Сообщение))(client, mes)
}

func (client *Client) Plugins(mes Сообщение) {
	PluginsList, err := filepath.Glob("./plugins/*.so")
	if err != nil {
		Инфо("ошибка открытия плагинов %+v\n", err)
		mes := Сообщение{
			Текст: err.Error(),
			От:    "io",
			Кому:  client.Login,
			Id:    -2, // -2 ошибка
		}
		client.Message <- &mes
	}
	for _, filename := range PluginsList {

		pluginFile, err := plugin.Open(filename)
		if err != nil {
			Инфо("ошибка открытия плагинов %+v\n", err)
			mes := Сообщение{
				Текст: "Не возможно загрузить плагины",
				От:    "io",
				Кому:  client.Login,
				Id:    -2, // -2 ошибка
			}
			client.Message <- &mes
		}
		Инфо("mes.Выполнить.Action %+v\n", mes.Выполнить.Action)
		Action, err := pluginFile.Lookup(mes.Выполнить.Action)
		Инфо("Action %+v\n", Action)
		if err != nil {
			mes := Сообщение{
				Текст: "Действие не существует",
				От:    "io",
				Кому:  client.Login,
				Id:    -2, // -2 ошибка
			}
			client.Message <- &mes
			return
		}

		argc := map[string]interface{}{
			"Clinet":  client,
			"Message": &mes,
		}
		Action.(func(map[string]interface{}))(argc)
	}
}

func (client *Client) ПолучитьАктивныйДиалог(mes Сообщение) {
	// Sql:    "SELECT * FROM iobot.io_dialogs_log WHERE uid = $1 AND status->>'завершено' IS NULL",
	client.АктивныеДиалоги, _ = ВыполнитьPgSQL(sqlStruct{
		Name: "dialogs_log",
		Sql:  "SELECT iobot.io_dialogs_log.id as active_id, iobot.io_dialogs_log.*, iobot.io_dialogs.* FROM iobot.io_dialogs_log LEFT JOIN iobot.io_dialogs ON iobot.io_dialogs_log.dialog_id = iobot.io_dialogs.dialog_id AND iobot.io_dialogs_log.message_id = iobot.io_dialogs.message_id WHERE uid = $1 AND status->>'завершено' IS NULL",
		Values: [][]byte{
			[]byte(client.Login),
		},
	})
	if len(client.АктивныеДиалоги) < 1 {
		return
	}

	for _, Диалог := range client.АктивныеДиалоги {
		if Диалог["status"] != "" {
			Статус := map[string]interface{}{}
			err := json.Unmarshal([]byte(Диалог["status"].(string)), &Статус)
			if err != nil {
				Ошибка("err	 %+v\n", err)
			} else {
				Диалог["status"] = Статус
			}
		}
		if Диалог["io"] != "" {
			ответИо := map[string]interface{}{}
			err := json.Unmarshal([]byte(Диалог["io"].(string)), &ответИо)
			if err != nil {
				Ошибка("err	 %+v\n", err)
			} else {
				Диалог["io"] = ответИо
			}
		}
	}
	//Инфо("\n \n client.АктивныеДиалоги %+v\n\n", client.АктивныеДиалоги)
}

//var client.АктивныеДиалоги []map[string]interface{}

func ЗавершитьДиалог(НомерДиалога interface{}, НомерСообщения interface{}) {

	Завершён, err := sqlStruct{
		Name: "io_dialogs",
		Sql:  "UPDATE iobot.история_диалогов_ио SET завершено = true  WHERE номер_диалога = $1 AND номер_сообщения = $2 RETURNING *",
		Values: [][]byte{
			[]byte(strconv.Itoa(НомерДиалога.(int))),   //АктивныйДиалог["active_id"].(string)
			[]byte(strconv.Itoa(НомерСообщения.(int))), //АктивныйДиалог["active_id"].(string)
		},
	}.Выполнить(nil)
	if err != nil {
		Инфо(">>>> ERROR \n %+v \n\n", err)
	} else {
		Инфо("Завершён диалог %+v\n", Завершён)
	}
}

func ЗавершитьАктивныйДиалог(result interface{}, dialog_id string) {
	status := map[string]interface{}{
		"завершено": "ok",
		"result":    result, //СтатусАктивногоДиалога["result"] ,
	}
	statusByte, err := json.Marshal(status)
	if err != nil {
		Инфо("err	 %+v\n", err)
	}
	Инфо("status %+v\n", string(statusByte))

	_, _ = ВыполнитьPgSQL(sqlStruct{
		Name: "io_dialogs",
		Sql:  "UPDATE iobot.io_dialogs_log SET status = status || $2  WHERE id = $1 RETURNING *",
		Values: [][]byte{
			[]byte(dialog_id), //АктивныйДиалог["active_id"].(string)
			statusByte,
		},
	})

}

// алгоритм
//	 Бот получает сообщение запрос от пользователя
//		Если у бота есть ответ на запрос то начинаеться диалог
// 			Каждый диалог строиться из вопросов бота клиенту, на которые бот ожидает, либо любую строку, либо один из вариантов ответа
//			Если у бота нет вопросов, но есть ответ/утверждение клиенту, то бот ничгео не ожидает. Скорей всего такой диалог не будет иметь продолжения и иметь ветвлений.
//		При активном диалоге бот проверяет входящее сообщение от клиента, если он ожидает любую строку/файл то при получении любой строки Бот исполняет Действие записаное в поле action c полученными данными. Перед отправкой ответа пользователю бот выполняет Действие записанно в final_action - если оно не пустое.
// 		Если бот ожидает один из вариантов ответа, то проверяет пришёл ли один из вариантов, если вариант  ответа найден, то проверяет есть ли у этого варианта поле action/действие, если есть то выполняет его, затем проверяет есть ли поле next/далее и поле final_action/действие, Если поля final_action пустое, то переходит с следущему вопросу  диалога, Если не пустое, то выполняем действие, и если нужно вернуть пользоватлею результат финального действия то финальное_дейсвтие должно вернуть данные в поле content.html
// 	По идее поле final-action можно проверять перед каждой отправкой сообщения клиенту, и выполнять из него действие
// алгоритм
//		Если АктивныйДиалог != nil {
//				Если АктивныйДиалог.Ожидает == ’строка’ {
//						Если АквтиныйДиалог.Действие != nil{
//							РезультатДействия := Выполнить[АквтиныйДиалог.Действие](СообщениеОтКлиента)
//						}
//						Если АквтиныйДиалог.Далее != nil{
//							ПолучитьСледующийШаг()
//						}
//						Если АквтиныйДиалог.Далее.ДействиеПередОтветом != nil{
//							РезультатДействияПередОтветом := Выполнить[АквтиныйДиалог.Далее.ДействиеПередОтветом](СообщениеОтКлиента)
//						}
//					}
//				Если АктивныйДиалог.Ожидает == ’вариант_ответа’ {
//							 Далее, содержит := АктивныйДиалог.Далее.Содержит["ответ_пользователя"]
//								if содержит {
//											Если Далее.Дейтвие != nil{
//													РезультатДействия := Выполнить[Далее.Дейсвтие](СообщениеОтКлиента)
//											}
//											Если Далее.Шаг != nil{
//													ПолучитьСледующийШаг()
//											}
//											Если Далее.ДействиеПередОтветом != nil{
//													РезультатДействияПередОтветом := Выполнить[Далее.ДействиеПередОтветом]()
//											}
//										}
//					}
//			} Иначел Если АктивныйДиалог == nil{
//				func НачатьНовыйДиалог() {
//						Диалог := НайтиДиалогСодержащийЗапросОтКлиента()
//						Если Диалог != nil{
//							Если Диалог.Далее.ДействиеПередОтветом != nil{
//								РезультатДействияПередОтветом := Выполнить[Диалог.Далее.ДействиеПередОтветом]()
//							}
//							Если Диалог.Ожидает != nil{ }
//						} иначе {
//							ВопросНеПонятен() // Отправляем пользователю сообщение что вопрос не понятен
//						}
//				}
//			}
//type Далее struct {
//	Шаг string // следуюющий шаг соответсвующий ответу пользователя
//	Действие string // Дейсвтеи которое нужно выполнить с полученными данными до перехода к слудеющему Шагу
//	ДействиеПередОтветом string // действие  которое нужно выполнить перед отправкой сообщения клиенту (получить какие либо данные, отрендерить ответ)
//} // в Следующий записываем то что соответсвует ответу клиента
//type Диалог struct {
//	Ожидает string // строка-любая строка без проверки содержимого строки, вариант_ответа - один из вариантов ответа для перехода кследующему шагу
//	//Действие string // действие которое нужно выполнить с получеными данными от клиента
//	Далее *Далее
//}
//type ОтветИО struct{
//	Утверждение string
//	Вопрос string
//	Ожидает string
//}

func (client *Client) НайтиАктивныйДиалог(вопрос *Сообщение) bool {
	АктивныйДиалог, err := sqlStruct{
		Name: "история_диалогов_ио",
		Sql:  `SELECT iobot.история_диалогов_ио.*, iobot.диалоги_ио.* FROM iobot.история_диалогов_ио LEFT JOIN iobot.диалоги_ио ON iobot.история_диалогов_ио.номер_диалога = iobot.диалоги_ио.номер_диалога AND iobot.история_диалогов_ио.номер_сообщения = iobot.диалоги_ио.номер_сообщения WHERE iobot.история_диалогов_ио.клиент = $1 AND завершено = false`,
		Values: [][]byte{
			[]byte(client.Login),
		},
	}.Выполнить(nil)
	if err != nil {
		Ошибка(">>>> ERROR \n %+v \n\n", err)
	}

	if len(АктивныйДиалог) > 0 {
		if len(АктивныйДиалог) == 1 {
			client.АктивныйДиалог = АктивныйДиалог[0]
			return true
		} else {
			// todo НУЖНО Выбрать активны диалоги, вывеси их клиенту и спросить хочет ли он завершить их
			// идея : Сделать так чтобы среди активных диалогов проверялся вариант ответа пришедший от пользователя

			СообщениеКлиенту := &Сообщение{
				Текст: "У Вас " + strconv.Itoa(len(АктивныйДиалог)) + " не завершённых диалога, я пока не могу продолжить. Нужно завершить все диалоги",
				От:    "io",
				Кому:  client.Login,
			}
			//СообщениеКлиенту.СохранитьЛогСообщения()
			//client.Message<-СообщениеКлиенту
			СообщениеКлиенту.СохранитьИОтправить(client)
			return false
		}
	} else {
		// нет актинвых диалогов
		//Инфо("нет актинвых диалогов %+v\n", АктивныйДиалог)
		//СообщениеКлиенту:= &Сообщение{
		//	Текст:  "Я пока не знаю что на это ответить",
		//	От: "io",
		//	Кому:client.Login,
		//}
		//СообщениеКлиенту.СохранитьЛогСообщения()
		//client.Message<-СообщениеКлиенту
		return false
	}
}

func (client *Client) СобратьОтправитьВариантыОтветов() {
	ПоследнееСообщение := client.АктивныйДиалог
	Далее, ЕстьСледующийШаг := ПоследнееСообщение["далее"]
	if !ЕстьСледующийШаг {
		// нет Следующего шага
		return
	}
	ВариантыОтвета := []string{}
	БыстрыеОтветы := ""
	for _, Шаг := range Далее.([]map[string]interface{}) {
		//ВариантыОтвета = append(ВариантыОтвета, Шаг["варианты_ответа"].([]interface{})...)

		for номер, ВариантОтвета := range Шаг["варианты_ответа"].([]interface{}) {
			ВариантыОтвета[номер] = ВариантОтвета.(string)
			БыстрыеОтветы = БыстрыеОтветы + ВариантОтвета.(string)
		}
	}

	СообщениеКлиенту := &Сообщение{
		Текст:       "Я не понял ответ.  Я спрашивал: <br>'-" + ПоследнееСообщение["message"].(string) + "'.<br> И ожидаю один из ответов: " + string(render("variantsArray", ВариантыОтвета)),
		От:          "io",
		Кому:        client.Login,
		MessageType: []string{"irritation", "io_action"},
	}
	//СообщениеКлиенту.СохранитьЛогСообщения()
	//client.Message<-СообщениеКлиенту
	СообщениеКлиенту.СохранитьИОтправить(client)
}

func (client *Client) ВопросИО(вопрос *Сообщение) {
	//Инфо(">> ВОПРОС БОТУ %+v от клиента %+v \n", вопрос.Текст, client)

	ЕстьАктивныйДиалог := client.НайтиАктивныйДиалог(вопрос)

	if ЕстьАктивныйДиалог {
		//&& ОтветНаВходящийВопрос == nil && client.АктивныйДиалог["номер_диалога"] == ОтветНаВходящийВопрос["номер_диалога"] {
		// Продолжаем активный диалог
		ПоследнееСообщение := client.АктивныйДиалог
		_, ИОожидаетОтвет := ПоследнееСообщение["ожидает"]

		if ИОожидаетОтвет {
			СледующийШаг := client.НайтиСледующийШаг(вопрос)

			if СледующийШаг == nil {
				// Собрать Варинта ответов и отправить раздражённое сообщение
				client.СобратьОтправитьВариантыОтветов()
			} else {

				Дейсвтие, НужноВыполнитьДействие := СледующийШаг["выполнить"]
				if НужноВыполнитьДействие {
					_ = Выполнить(Дейсвтие.(string), client, вопрос)

				}

				Навык, НужноВыполнитьНавык := СледующийШаг["навык"]
				Инфо("НужноВыполнитНавык %+v Навык %+v\n", НужноВыполнитьНавык, Навык)

				if НужноВыполнитьНавык {
					ЛогВыполненияНавыка, errors := client.ЗапуститьНавыкПоИмени(Навык.(string))
					if errors != nil {
						ЗавершитьДиалог(ПоследнееСообщение["номер_диалога"], ПоследнееСообщение["номер_сообщения"])
						СледующийШаг = nil
					} else {
						Инфо("ЛогВыполненияНавыка %+v\n", ЛогВыполненияНавыка)
						ЗавершитьДиалог(ПоследнееСообщение["номер_диалога"], ПоследнееСообщение["номер_сообщения"])
					}
				}

			}

			if СледующийШаг != nil {
				//client.ОбработатьСообщениеИОтветитьКлиенту(СледующийШаг, вопрос) // следующий шаг
			}

		}
	} else {
		// Начнём НовыйДиалог
		ДейсвтияДляОтветаНаЗапрос := client.НайтиОтветНаСообщение(вопрос)
		//Инфо(" НачатьДиалог %+v", ДейсвтияДляОтветаНаЗапрос)
		client.НачатьДиалог(вопрос, ДейсвтияДляОтветаНаЗапрос)
	}
}

func (client *Client) НайтиДиалогПоНомер(НомерДиалога int, НомерСообщения int) map[string]interface{} {

	SQLВсеДиалоги := `select result.ид,
       result.номер_диалога,
       result.номер_сообщения,
       result.html_шаблон,
       result.json_данные,
       result.ответ,
       jsonb_agg(result.sql_запрос)  sql_запрос
from (select iobot.диалоги_ио.ид,
                       iobot.диалоги_ио.номер_диалога,
                       iobot.диалоги_ио.номер_сообщения,
                       iobot.диалоги_ио.доступ,
                       iobot.диалоги_ио.html_шаблон,
                       iobot.диалоги_ио.json_данные,
                       запросы_диалоги.очерёдность,
                       case
                           when запросы.ид_запроса IS null
                               then
                               null
                           else jsonb_build_object(запросы_диалоги.очерёдность, jsonb_object_agg(coalesce(запросы.имя, 'нет'), jsonb_build_object('скрипт',запросы.скрипт,'аргументы',запросы.аргументы, 'динамический', запросы.динамический, 'аргументы_динамического_запроса', запросы.аргументы_динамического_запроса, 'динамический_шаблон', запросы.динамический_шаблон,'обработчик', запросы.обработчик,'данные_обработчика',запросы.данные_обработчика, 'база_данных',запросы.база_данных, 'комментарий',запросы.коментарий)))
                           end sql_запрос,
                       jsonb_build_object('утверждение', ответ.утверждение, 'вопрос', ответ.вопрос, 'ожидает',
                                          ответ.ожидает, 'выполнить', ответ.выполнить) ответ -- рабочий вариант
                from iobot.диалоги_ио
						join fssp_configs.УровеньДоступаПользователя ON
                        логин = $2 AND
                        диалоги_ио.доступ ?| (case
                                                  when УровеньДоступаПользователя.расширенный_доступ[1] is not null then
                                                      УровеньДоступаПользователя.расширенный_доступ
                                                  when (УровеньДоступаПользователя.расширенный_доступ[1] is null)
                                                      AND (УровеньДоступаПользователя.основной_доступ[1] is null) then
                                                      ARRAY ['неизвестный'::varchar]
                                                  else
                                                      УровеньДоступаПользователя.основной_доступ
                            end)
                         left join iobot.запросы_диалоги ON iobot.запросы_диалоги.ид_диалога = диалоги_ио.ид
                         left join iobot.запросы ON
                        iobot.запросы_диалоги.ид_запроса = iobot.запросы.ид_запроса
                        and iobot.запросы.доступ ?| (case
                                                         when УровеньДоступаПользователя.расширенный_доступ[1] is not null
                                                             then
                                                             УровеньДоступаПользователя.расширенный_доступ
                                                         when (УровеньДоступаПользователя.расширенный_доступ[1] is null)
                                                             AND (УровеньДоступаПользователя.основной_доступ[1] is null)
                                                             then
                                                             ARRAY ['неизвестный'::varchar]
                                                         else
                                                             УровеньДоступаПользователя.основной_доступ
                        end)
                         left join iobot.ответ ON
                        (iobot.диалоги_ио.номер_диалога = iobot.ответ.номер_диалога AND
                         iobot.диалоги_ио.номер_сообщения = iobot.ответ.номер_сообщения)
                        and iobot.ответ.доступ ?| (case
                                                       when УровеньДоступаПользователя.расширенный_доступ[1] is not null
                                                           then
                                                           УровеньДоступаПользователя.расширенный_доступ
                                                       when (УровеньДоступаПользователя.расширенный_доступ[1] is null)
                                                           AND (УровеньДоступаПользователя.основной_доступ[1] is null)
                                                           then
                                                           ARRAY ['неизвестный'::varchar]
                                                       else
                                                           УровеньДоступаПользователя.основной_доступ
                        end)
                WHERE iobot.диалоги_ио.номер_диалога = $1 AND  iobot.диалоги_ио.номер_сообщения = 1
                GROUP BY iobot.диалоги_ио.ид,
                         iobot.диалоги_ио.номер_диалога,
                         iobot.диалоги_ио.номер_сообщения,
                         iobot.диалоги_ио.доступ,
                         iobot.диалоги_ио.html_шаблон,
                         iobot.диалоги_ио.json_данные,
                         ответ.утверждение, ответ.выполнить,
                         ответ.вопрос, ответ.ожидает, запросы.ид_запроса, запросы.аргументы,запросы_диалоги.очерёдность ORDER BY запросы_диалоги.очерёдность ASC
            ) result GROUP BY result.ид,
                              result.номер_диалога,
                              result.номер_сообщения,
                              result.доступ,
                              result.html_шаблон,
                              result.json_данные,
                              result.ответ`

	Диалоги, err := sqlStruct{
		Name: "диалоги_ио",
		Sql:  SQLВсеДиалоги,
		Values: [][]byte{
			[]byte(strconv.Itoa(НомерДиалога)),
			[]byte(client.Login),
		},
	}.Выполнить(nil)
	if err != nil {
		Инфо(" %+v ", err)
	}
	if len(Диалоги) > 0 {
		if len(Диалоги) == 1 {
			return Диалоги[0]
		} else {
			Ошибка("Диалоги > 1%+v ", Диалоги)
			return nil
		}
	}
	return nil
}

/*НайтиОтветНаСообщение
Выдёт данные только для пользователя удовлетворящие конкретному уровню доступа, или расширенному или основному...
Для админов нужно будет написать дополнительную фуункциию которая будет выдавать данные для основного уровня доступа так как это видит обычный пользователь

*/
func (client *Client) НайтиОтветНаСообщение(вопрос *Сообщение) map[string]interface{} {
	//Инфо("НайтиОтветНаСообщение вопрос %+v", вопрос)

	//	SQLВсеДиалоги := `select
	//    ид,
	//    номер_диалога,
	//    номер_сообщения,
	//    доступ,
	//    вид_доступа,
	//    html,
	//    json_данные,
	//    обработчик,
	//    данные_обработчика,
	//    обработка_ошибок,
	//    jsonb_object_agg(очерёдность,sql_запрос) sql_запрос
	//from (
	//         select iobot.диалоги_ио.ид,
	//                iobot.диалоги_ио.номер_диалога,
	//                iobot.диалоги_ио.номер_сообщения,
	//                iobot.диалоги_ио.доступ,
	//                case when диалоги_ио.доступ ?| УровеньДоступаПользователя.расширенный_доступ then 'расширенный'
	//                     when диалоги_ио.доступ ?| УровеньДоступаПользователя.основной_доступ then 'основной' end as вид_доступа,
	//                iobot.диалоги_ио.html,
	//                iobot.диалоги_ио.json_данные,
	//                iobot.диалоги_ио.обработчик,
	//                iobot.диалоги_ио.данные_обработчика,
	//                запросы_диалоги.очерёдность,
	//                case
	//                    when iobot.запросы.ид_запроса IS null
	//                        then
	//                        null
	//                    else
	//                        jsonb_object_agg(coalesce(запросы.имя, 'нет'), запросы)
	//                    end sql_запрос,
	//                case
	//                    when обработка_ошибок.ид_запроса IS null
	//                        then
	//                        null
	//                    else
	//                         jsonb_build_object(coalesce(обработка_ошибок.ид_запроса::varchar, 'обработка_ошибок'),
	//                                           jsonb_object_agg(coalesce(обработка_ошибок.код, 0), обработка_ошибок)
	//                            )
	//                    end обработка_ошибок
	//         from iobot.диалоги_ио
	//                  left join fssp_configs.УровеньДоступаПользователя ON lower(логин) = lower($2)
	//                  left join iobot.запросы_диалоги ON iobot.запросы_диалоги.ид_диалога = диалоги_ио.ид
	//                  join iobot.запросы ON iobot.запросы_диалоги.ид_запроса = iobot.запросы.ид_запроса
	//                    OR iobot.запросы.активирующее_сообщение @> iobot.диалоги_ио.активирующее_сообщение
	//                  left join iobot.обработка_ошибок ON iobot.запросы.ид_запроса = iobot.обработка_ошибок.ид_запроса
	//         WHERE диалоги_ио.активирующее_сообщение ? $1
	//           and case
	//                   when УровеньДоступаПользователя is not null then
	//                               диалоги_ио.доступ ?| УровеньДоступаПользователя.расширенный_доступ
	//                           OR диалоги_ио.доступ ?| УровеньДоступаПользователя.основной_доступ
	//                   else диалоги_ио.доступ ?| '{"неизвестный"}' end
	//           and case
	//                   when УровеньДоступаПользователя is not null then
	//                               iobot.запросы.доступ ?| УровеньДоступаПользователя.расширенный_доступ
	//                           OR iobot.запросы.доступ ?| УровеньДоступаПользователя.основной_доступ
	//                   else iobot.запросы.доступ ?| '{"неизвестный"}' end
	//           and ARRAY(select jsonb_array_elements(диалоги_ио.доступ)) &&
	//               ARRAY(select jsonb_array_elements(iobot.запросы.доступ))
	//
	//         GROUP BY iobot.диалоги_ио.ид,
	//                  iobot.диалоги_ио.номер_диалога,
	//                  iobot.диалоги_ио.номер_сообщения,
	//                  iobot.диалоги_ио.доступ,
	//                  УровеньДоступаПользователя.расширенный_доступ,
	//                  УровеньДоступаПользователя.основной_доступ,
	//                  iobot.диалоги_ио.html,
	//                  iobot.диалоги_ио.json_данные,
	//                  запросы.ид_запроса,
	//                  запросы_диалоги.очерёдность,
	//                  iobot.диалоги_ио.обработчик,
	//                  iobot.диалоги_ио.данные_обработчика,
	//                  iobot.обработка_ошибок.ид_запроса
	//
	//     ) t
	//
	//group by
	//    ид,
	//    номер_диалога,
	//    номер_сообщения,
	//    вид_доступа,
	//    доступ,
	//    html,
	//    json_данные,
	//    обработчик,
	//    данные_обработчика,
	//    обработка_ошибок
	//`
	SQLВсеДиалоги := `select result.ид,
      result.номер_диалога,
      result.номер_сообщения,
      result.доступ,
      result.html_шаблон,
      result.json_данные,
      result.ответ,
      jsonb_agg(result.sql_запрос)  sql_запрос
from (select iobot.диалоги_ио.ид,
            iobot.диалоги_ио.номер_диалога,
            iobot.диалоги_ио.номер_сообщения,
            iobot.диалоги_ио.доступ,
            iobot.диалоги_ио.html_шаблон,
            iobot.диалоги_ио.json_данные,
            запросы_диалоги.очерёдность,
            case
                when запросы.ид_запроса IS null
                    then
                    null
                else
                    jsonb_build_object(запросы_диалоги.очерёдность, jsonb_object_agg(coalesce(запросы.имя, 'нет'), jsonb_build_object('скрипт',запросы.скрипт,'аргументы',запросы.аргументы, 'динамический', запросы.динамический, 'аргументы_динамического_запроса', запросы.аргументы_динамического_запроса, 'динамический_шаблон', запросы.динамический_шаблон,'обработчик', запросы.обработчик,'данные_обработчика',запросы.данные_обработчика, 'база_данных',запросы.база_данных, 'комментарий',запросы.коментарий)))
                end sql_запрос,
            jsonb_build_object('утверждение', ответ.утверждение, 'вопрос', ответ.вопрос, 'ожидает',
                               ответ.ожидает, 'выполнить', ответ.выполнить) ответ -- рабочий вариант
     from iobot.диалоги_ио
                join fssp_configs.УровеньДоступаПользователя ON
                 логин = $2 AND
                 диалоги_ио.доступ ?| (case
                                           when УровеньДоступаПользователя.расширенный_доступ[1] is not null then
                                               УровеньДоступаПользователя.расширенный_доступ
                                           when (УровеньДоступаПользователя.расширенный_доступ[1] is null)
                                               AND (УровеньДоступаПользователя.основной_доступ[1] is null) then
                                               ARRAY ['неизвестный'::varchar]
                                           else
                                               УровеньДоступаПользователя.основной_доступ
                     end)
              left join iobot.запросы_диалоги ON iobot.запросы_диалоги.ид_диалога = диалоги_ио.ид
              left join iobot.запросы ON
                 iobot.запросы_диалоги.ид_запроса = iobot.запросы.ид_запроса
             and iobot.запросы.доступ ?| (case
                                              when УровеньДоступаПользователя.расширенный_доступ[1] is not null
                                                  then
                                                  УровеньДоступаПользователя.расширенный_доступ
                                              when (УровеньДоступаПользователя.расширенный_доступ[1] is null)
                                                  AND (УровеньДоступаПользователя.основной_доступ[1] is null)
                                                  then
                                                  ARRAY ['неизвестный'::varchar]
                                              else
                                                  УровеньДоступаПользователя.основной_доступ
             end)
              left join iobot.ответ ON
             (iobot.диалоги_ио.номер_диалога = iobot.ответ.номер_диалога AND
              iobot.диалоги_ио.номер_сообщения = iobot.ответ.номер_сообщения)
             and iobot.ответ.доступ ?| (case
                                            when УровеньДоступаПользователя.расширенный_доступ[1] is not null
                                                then
                                                УровеньДоступаПользователя.расширенный_доступ
                                            when (УровеньДоступаПользователя.расширенный_доступ[1] is null)
                                                AND (УровеньДоступаПользователя.основной_доступ[1] is null)
                                                then
                                                ARRAY ['неизвестный'::varchar]
                                            else
                                                УровеньДоступаПользователя.основной_доступ
             end)
     WHERE iobot.диалоги_ио.активирующее_сообщение ? lower($1)
     GROUP BY iobot.диалоги_ио.ид,
              iobot.диалоги_ио.номер_диалога,
              iobot.диалоги_ио.номер_сообщения,
              iobot.диалоги_ио.доступ,
              iobot.диалоги_ио.html_шаблон,
              iobot.диалоги_ио.json_данные,
              ответ.утверждение, ответ.выполнить,
              ответ.вопрос,
              ответ.ожидает,
              запросы.ид_запроса,
				запросы_диалоги.очерёдность
     ORDER BY запросы_диалоги.очерёдность ASC
    ) result GROUP BY result.ид,
                      result.номер_диалога,
                      result.номер_сообщения,
                      result.доступ,
                      result.html_шаблон,
                      result.json_данные,
                      result.ответ`

	Инфо("strings.TrimSpace(вопрос.Текст) %+v Login %+v\n", вопрос.Текст, client.Login)
	//Инфо(" client.UserInfo %+v",  client.UserInfo)

	Диалоги, err := sqlStruct{
		Name: "диалоги_ио",
		Sql:  SQLВсеДиалоги,
		Values: [][]byte{
			[]byte(strings.TrimSpace(вопрос.Текст)),
			[]byte(client.Login),
		},
	}.Выполнить(nil)
	if err != nil {
		Инфо(" %+v ", err)
	}
	if len(Диалоги) > 0 {
		if len(Диалоги) == 1 {
			Диалог := Диалоги[0]

			// если было обновление f5 = true проверим номер сообщения в очереди диалогов. Потому что если номер сообщения больше 1 то вероятно нет родительсокго контейнера куда вставлять ответ, получим первое сообщение, и отдадим ответ клиенту, восстановим страницу...
			//	Инфо(" обновление или первый вход по ссылке %+v", вопрос)
			if вопрос.F5 {
				Инфо(" обновление или первый вход по ссылке %+v", вопрос)
				if Диалог["номер_диалога"] != nil {
					РодительскийЗапрос := client.НайтиДиалогПоНомер(Диалог["номер_диалога"].(int), Диалог["номер_сообщения"].(int))

					Инфо("Выполняем дейсвтия из первого сообщения Диалога. Чтобы востановить контейнер данных %+v")

					client.НачатьДиалог(вопрос, РодительскийЗапрос)
				}

			}
			Инфо("Вовзращаем данные для обработки текущего запроса %+v , Диалоги: %+v", вопрос, Диалоги)
			return Диалог
		} else {

			Инфо("Количество диалгов %+v , Диалоги: %+v", len(Диалоги), Диалоги)
			СообщениеКлиенту := &Сообщение{
				Текст: "Есть  " + strconv.Itoa(len(Диалоги)) + " варианта/ов сценария, я пока не могу понять какой из них нужно выполнить.",
				От:    "io",
				Кому:  client.Login,
			}
			//СообщениеКлиенту.СохранитьЛогСообщения()
			//client.Message<-СообщениеКлиенту
			СообщениеКлиенту.СохранитьИОтправить(client)
			return nil
		}
	} else {
		Инфо("Количество диалгов %+v , Диалоги: %+v", len(Диалоги), Диалоги)
		return nil
	}
}

func УдалитьФайл(client *Client) {

}

/*
ВыполнитьSQLвАИС
Выполняет зпрос в аис и выводит результат в виде таблице, не доработано
*/
func (client *Client) ВыполнитьSQLвАИС(вопрос Сообщение) map[string]interface{} {
	SQLQuery := вопрос.Выполнить.Действие["выполнить sql в аис"]["sql"]
	conn := RDBconnect()
	defer conn.Close()
	Инфо("SQLQuery %+v\n", SQLQuery)
	РезультатЗапроса, errResultSql := conn.Query(SQLQuery.(string))
	if errResultSql != nil {
		Инфо("err	 %+v sql.Sql %+v \n", errResultSql, SQLQuery)
	}
	if РезультатЗапроса == nil {
		Инфо("Запрос не вернул данных %+v\n", РезультатЗапроса)
		return nil
	} else {
		//resultMaps := map[string]interface{}{}

		Строки := [][]string{}

		//savedRows := [][][]byte{}
		//savedRowsStrings:= [][]string{}
		Столбцы, err := РезультатЗапроса.Columns()
		for РезультатЗапроса.Next() {
			Строка := []string{}
			if err != nil {
				Ошибка("err	 %+v\n", err)
			}

			Значения := make([]interface{}, len(Столбцы))
			for i, _ := range Столбцы {
				Значения[i] = new(sql.NullString)
			}

			//savedValues := [][]byte{}

			//vals := make([]interface{}, len(cols))
			//Инфо("len vals %+v len(cols) %+v cols %+v\n", len(vals), len(cols), cols)

			err = РезультатЗапроса.Scan(Значения...)

			if err != nil {
				Ошибка("Ошибка сканирования строки %+v a %+v\n", err, Значения)
			}

			//Строки=append(Строки, Значения[i].(*sql.NullString).String)

			for _, Значение := range Значения {
				//resultMaps[colName] = vals[i].(*sql.NullString).String
				//Инфо("vals[i] %+v\n", vals[i].(*sql.NullString).String)
				//resultMaps[ИмяСтолбца] =Значения[i].(*sql.NullString).String
				//savedValues=append(savedValues, []byte(Значения[i].(*sql.NullString).String))

				Строка = append(Строка, Значение.(*sql.NullString).String)
			}
			Строки = append(Строки, Строка)

		}
		Таблица := map[string]interface{}{
			"Контейнер": "main_content.sql_query.table_wraper",
			"HTML": render("TableGenerator", map[string]interface{}{
				"Столбцы": Столбцы,
				"Строки":  Строки,
			}),
		}
		Инфо("Таблица Строки %+v", Строки)
		return Таблица

	}
}

func (client *Client) НачатьДиалог(вопрос *Сообщение, ДейсвтияДляОтветаНаЗапрос map[string]interface{}) {
	Инфо(">>> НачатьДиалог: \n вопрос %+v \n Диалоги %+v\n", вопрос, ДейсвтияДляОтветаНаЗапрос)

	//OSPCode := strconv.Itoa(client.UserInfo.Info.OspCode)
	//Post := strconv.Itoa(client.UserInfo.Info.Post)
	if ДейсвтияДляОтветаНаЗапрос == nil {
		СообщениеКлиенту := &Сообщение{
			Текст: "Я пока не знаю что на это ответить",
			От:    "io",
			Кому:  client.Login,
		}
		//СообщениеКлиенту.СохранитьЛогСообщения()
		//client.Message<-СообщениеКлиенту
		СообщениеКлиенту.СохранитьИОтправить(client)
		return
	}

	client.ОбработатьСообщениеИОтветитьКлиенту(ДейсвтияДляОтветаНаЗапрос, вопрос) // НачатьДиалог
}

func (client *Client) НайтиСледующийШаг(вопрос *Сообщение) map[string]interface{} {
	ПоследнееСообщение := client.АктивныйДиалог
	// Находим следующий Шаг в диалоге,

	Инфо("ПоследнееСообщение %+v\n", ПоследнееСообщение)
	Инфо("НайтиСледующийШаг %+v\n", вопрос)

	ПолучитьСледующееСообщение, _ := sqlStruct{
		Name: "io_dialogs",
		Sql: `SELECT ТекущееСообщение.выполнить, ТекущееСообщение.навык, СледующийШаг.* FROM
							(SELECT номер_диалога,
									jsonb_array_elements(далее)::jsonb->> 'варианты_ответа' as варианты_ответа,
									jsonb_array_elements(далее)::jsonb->> 'шаг' as шаг,
									jsonb_array_elements(далее)::jsonb->> 'выполнить' as выполнить,
									jsonb_array_elements(далее)::jsonb->> 'навык' as навык
							 FROM iobot.диалоги_ио WHERE (номер_диалога = $2 AND  номер_сообщения = $3)
							 ) as ТекущееСообщение
						    JOIN iobot.диалоги_ио as СледующийШаг ON СледующийШаг.номер_сообщения::text = ТекущееСообщение.шаг AND ТекущееСообщение.номер_диалога = СледующийШаг.номер_диалога
					WHERE  (CASE WHEN ТекущееСообщение.варианты_ответа::jsonb IS NOT NULL THEN ТекущееСообщение.варианты_ответа::jsonb ? lower($1) ELSE true END)`,
		Values: [][]byte{
			[]byte(strings.TrimSpace(вопрос.Текст)),
			[]byte(strconv.Itoa(ПоследнееСообщение["номер_диалога"].(int))),
			[]byte(strconv.Itoa(ПоследнееСообщение["номер_сообщения"].(int))),
		},
	}.Выполнить(nil)

	if len(ПолучитьСледующееСообщение) == 0 {
		return nil
	} else {
		Инфо("ПолучитьСледующееСообщение %+v\n", ПолучитьСледующееСообщение)
		return ПолучитьСледующееСообщение[0]
	}

}

func СобратьСтатДанные(client *Client, ДанныеОбработчка interface{}, ДанныеИзБд interface{}, ВходящиеДанные map[string]interface{}) map[string]interface{} {
	ВремяСтарта := Сегодня()

	Инфо("СобратьСтатДанные %+v", СобратьСтатДанные)
	Инфо("ВходящиеДанные %+v", ВходящиеДанные)
	Инфо("ДанныеИзБд %+v", ДанныеИзБд)
	for n, ДанныеСкрипта := range ДанныеИзБд.([]map[string]interface{}) {
		Инфо("Скрипт  %+v ДанныеСкрипта %+v", n, ДанныеСкрипта)
		if ДанныеСкрипта["ид_спец_фильтра"] != nil && ДанныеСкрипта["ид_спец_фильтра"] != "" {
			return СобратьИВыполнитьСпецФильтры(client, ДанныеОбработчка, ДанныеСкрипта, ВходящиеДанные)
		} else if ДанныеСкрипта["ид_запроса"] != nil && ДанныеСкрипта["ид_запроса"] != "" {

			Результат := ВыполнитьSQLЗапрос(client, ДанныеОбработчка, ВремяСтарта, ДанныеСкрипта, ВходящиеДанные)
			СообщениеКлиенту := Сообщение{
				Текст: "Данные ответа на запрос",
				От:    "io",
				Кому:  client.Login,
				Контэнт: &ДанныеОтвета{
					Данные: Результат,
				},
				//MessageType: []string{"irritation","io_action"},
			}
			СообщениеКлиенту.СохранитьИОтправить(client)
		}
	}
	return nil
}

func ВыполнитьSQLЗапрос(client *Client, ДанныеОбработчка interface{}, ВремяСтарта string, ДанныеСкрипта interface{}, ВходящиеДанные map[string]interface{}) map[string]map[string]РезультатSQLизАИС {

	Инфо("ДанныеСкрипта %+v", ДанныеСкрипта)
	данные := ДанныеСкрипта.(map[string]interface{})

	РезультатЗапроса, ОшибкаЗапроса := sqlStruct{
		Name: "Получить запрос для сбора данных",
		Sql:  "SELECT * FROM статистика.sql_запросы WHERE id = $1",
		Values: [][]byte{
			[]byte(данные["ид_запроса"].(string)),
		},
	}.Выполнить(nil)

	if ОшибкаЗапроса != nil {
		Ошибка(" %+v ", ОшибкаЗапроса)
	}

	SQLЗапрос := РезультатЗапроса[0]

	Инфо("SQLЗапрос %+v", SQLЗапрос)
	Инфо("данные %+v", данные)
	Инфо("ДанныеОбработчка %+v", ДанныеОбработчка)
	Инфо("ВходящиеДанные %+v", ВходящиеДанные)
	// проверим  требуются ли щапросу какие либо аргументы,

	//Необходимо добавить обработку динамиского скрипта
	var Скрипт string
	tpl, err := txtTpl.New("SqlЗапрос").Funcs(tplFunc()).Parse(SQLЗапрос["запрос"].(string))
	if err != nil {
		Ошибка("err %+v tpl %+v ", err, tpl)
	}

	БайтБуферДанных := new(bytes.Buffer)
	Инфо("Данные передаваемые в динамический sql %+v", ВходящиеДанные)
	err = tpl.Execute(БайтБуферДанных, ВходящиеДанные)
	if err != nil {
		Ошибка(" %+v ", err)
	} else {
		Скрипт = БайтБуферДанных.String()
		Скрипт = strings.TrimSpace(Скрипт)
	}
	Инфо("Скрипт  %+v \n БайтБуферДанных %+s \n АргументыSQL %+s ", Скрипт, БайтБуферДанных, ВходящиеДанные["data"])

	//var Аргументы map[string]map[string]interface{}
	//var АргументыДляЗапроса []interface{}
	/*
	      АргументыДляЗапроса нужно собрать жанные из ВходящиеДанные которые нужно отправить в запрос в качестве занчений

	   	Чтобы не заморачиваться, буду вписыать значения переданые с клиента в шаблонизаторе

	*/

	Инфо(" SQLЗапрос[\"id\"].(string) %+v", SQLЗапрос["id"].(string))

	//ИДзапроса := strconv.Itoa(int(SQLЗапрос["id"].(float64)))
	Инфо("Скрипт %+v", Скрипт)
	РезультатЗапросаИзАИС, ОшибкаЗапроса := sqlStruct{
		Name:       SQLЗапрос["id"].(string),
		Sql:        Скрипт,
		БазаДанных: SQLЗапрос["база"].([]interface{})[0].(string),
		Клиент:     client,
	}.ВыполнитьЗапросВАИС()

	сохранено := make(chan string)
	СохранитьДанныеСпецФильтров(данные["ид_таблицы"].(string), РезультатЗапросаИзАИС, ВремяСтарта, сохранено)
	for {
		Инфо("ОжиданиеДанных  %+v", данные["ид_таблицы"].(string))
		ИдСпецФильтра := <-сохранено
		if ИдСпецФильтра != "" {
			Инфо("сохранено %+v", ИдСпецФильтра)
			//break
		}
	}

	return РезультатЗапросаИзАИС
}

func СобратьИВыполнитьСпецФильтры(client *Client, ДанныеОбработчка interface{}, ДанныеИзБд interface{}, ВходящиеДанные map[string]interface{}) map[string]interface{} {
	Инфо("ДанныеИзБд %+v", ДанныеИзБд)
	СпецФильтры := map[string]map[string]interface{}{}
	ДанныеСпецФильтров := map[string]interface{}{}
	ИДСтатТаблицы := ""
	ВремяСтарта := Сегодня()
	КоличествоЗапущенныхСпецФильтров := 0

	if НомерЗапроса := ДанныеОбработчка.(map[string]interface{})["запрос"]; НомерЗапроса != nil {
		ИДзапроса := strconv.Itoa(int(НомерЗапроса.(float64)))

		РезультатЗапроса, ОшибкаЗапроса := sqlStruct{
			Name: "Получить запрос для сохранения данных",
			Sql:  "SELECT * FROM iobot.запросы WHERE ид_запроса = $1",
			Values: [][]byte{
				[]byte(ИДзапроса),
			},
		}.Выполнить(nil)
		if ОшибкаЗапроса != nil {
			Ошибка("  %+v", ОшибкаЗапроса)
		}
		Инфо("  РезультатЗапроса %+v", РезультатЗапроса)
		//Инфо("  ДанныеИзБд %+v", reflect.TypeOf(ДанныеИзБд))
		var КартаСкрипта map[string]interface{}

		if len(РезультатЗапроса) == 1 {
			КартаСкрипта = РезультатЗапроса[0]
		}

		канал := make(chan interface{}, len(ДанныеИзБд.(map[string]interface{})))
		Инфо(" размер канала %+v", len(ДанныеИзБд.(map[string]interface{})))
		завершено := make(chan string, КоличествоЗапущенныхСпецФильтров)

		//for _, данные := range ДанныеИзБд.(map[string]interface{}){
		данные := ДанныеИзБд.(map[string]interface{})
		СтрокаСтолбцов := ""
		Групировка := ""
		ИДСтатТаблицы = данные["ид_таблицы"].(string)

		if СпецФильтры[ИДСтатТаблицы] == nil {
			СпецФильтры[ИДСтатТаблицы] = map[string]interface{}{}
		}

		Инфо("СпецФильтры %+v", СпецФильтры)

		if Столбцы, ok := данные["детализация"]; ok {
			if len(Столбцы.([]interface{})) > 0 {
				for номер, Столбец := range Столбцы.([]interface{}) {
					СтрокаСтолбцов = СтрокаСтолбцов + Столбец.(string)
					if len(Столбцы.([]interface{})) > номер+1 {
						СтрокаСтолбцов = СтрокаСтолбцов + ","
					}
				}
			} else {
				СтрокаСтолбцов = " count(*) "
				Групировка = " GROUP BY OSP_CODE"
			}
		}

		ДанныеДляСкрипта := map[string]string{
			"столбцы":         СтрокаСтолбцов,
			"ид_спец_фильтра": данные["ид_спец_фильтра"].(string),
			"групировка":      Групировка,
		}

		Скрипт := КартаСкрипта["скрипт"].(string)

		tpl, err := txtTpl.New("SqlЗапрос").Funcs(tplFunc()).Parse(Скрипт)
		if err != nil {
			Ошибка("err %+v tpl %+v ", err, tpl)
		}

		БайтБуферДанных := new(bytes.Buffer)
		Инфо("Данные передаваемые в динамический sql %+v", ДанныеДляСкрипта)
		err = tpl.Execute(БайтБуферДанных, ДанныеДляСкрипта)
		if err != nil {
			Ошибка(" %+v ", err)
		} else {
			Скрипт = БайтБуферДанных.String()
			Скрипт = strings.TrimSpace(Скрипт)
		}
		Инфо("Скрипт %+v", Скрипт)

		РезультатЗапросаИзАИС, ОшибкаЗапроса := sqlStruct{
			Name:       данные["ид_спец_фильтра"].(string),
			Sql:        Скрипт,
			БазаДанных: "rdb",
			Клиент:     client,
		}.ВыполнитьЗапросВАИС()
		Инфо(" %+v - РезультатЗапросаИзАИС: %+v", данные["ид_спец_фильтра"].(string), РезультатЗапросаИзАИС)
		if ОшибкаЗапроса != nil {
			Ошибка(" %+v ", ОшибкаЗапроса)
		}
		Инфо("Запуск ОжиданиеДанных ИДСтатТаблицы %+v ВремяСтарта %+v", ИДСтатТаблицы, ВремяСтарта)
		go ОжиданиеДанных(ИДСтатТаблицы, ВремяСтарта, канал, завершено)

		for ИдСкрипта, Данные := range РезультатЗапросаИзАИС {
			Инфо("ИдСкрипта  %+v, Данные %+v", ИдСкрипта, Данные)
			for _, ДанныеЗапроса := range Данные {
				if len(ДанныеЗапроса.МассивСтрок) < 1 {
					continue
				}

				СпецФильтры[ИДСтатТаблицы][ИдСкрипта] = ДанныеЗапроса.МассивСтрок[0]

				КоличествоЗапущенныхСпецФильтров++
				Инфо("КоличествоЗапущенныхСпецФильтров %+v", КоличествоЗапущенныхСпецФильтров)
				//go ПолучитьДанныеИзАИСвПотоке(sqlStruct{
				//	Name:            ИдСкрипта,
				//	Table: 			 ИДСтатТаблицы,
				//	Sql:             ДанныеЗапроса.МассивСтрок[0]["SQL_QUERY"].(string),
				//	БазаДанных: "rdb",
				//	Клиент: client,
				//}, канал)
				ДанныеSql := sqlStruct{
					Name:       ИдСкрипта,
					Table:      ИДСтатТаблицы,
					Sql:        ДанныеЗапроса.МассивСтрок[0]["SQL_QUERY"].(string),
					БазаДанных: "rdb",
					Клиент:     client,
				}

				go func(ДанныеSql sqlStruct, канал chan interface{}) {
					Инфо(" Запрашиваем данные : %+v", ДанныеSql.Name)
					РезультатЗапроса, ОшибкаЗапроса := ДанныеSql.ВыполнитьЗапросВАИС()
					if ОшибкаЗапроса != nil {
						Ошибка("  %+v", ОшибкаЗапроса)
						канал <- ОшибкаЗапроса
					}
					if ОшибкаЗапроса != nil {
						Ошибка(" %+v ", ОшибкаЗапроса)
					}

					канал <- РезультатЗапроса

				}(ДанныеSql, канал)

			}
		}
		//}

		//завершено := make(chan string, КоличествоЗапущенныхСпецФильтров)

		//go ОжиданиеДанных (ИДСтатТаблицы,ВремяСтарта, канал, завершено)

		for КоличествоЗапущенныхСпецФильтров > 0 {
			Инфо("ожидаем данные из %+v источников", КоличествоЗапущенныхСпецФильтров)
			ИдСпецФильтра := <-завершено
			Инфо("ИдСпецФильтра %+v", ИдСпецФильтра)

			if ИдСпецФильтра != "" {

				// Получим Статистические данные по только что записанным данным, и вернём их
				РезультатЗапроса, ОшибкаЗапроса := sqlStruct{
					Name: `стат_таблица`,
					Sql: `select
							   jsonb_object_agg(осп::varchar, данные) данные,
							   дата#>>'{"дата"}' дата,
							   t.таблица таблица
						from
							(
								select имя_таблицы,
									   jsonb_object_agg('дата',дата) дата,
									   осп,
									   jsonb_object_agg(ид_спец_фильтра, данные) данные
						
								from (select имя_таблицы,
						
											 t.осп,
											 t.ид_спец_фильтра,
											 дата,
											 jsonb_build_object( 'имя_осп', t.osp_name, 'имя_столбца', t.имя_столбца,
																 'Количество', case
																				   when число is not null then
																					   sum(число)::varchar
																				   else
                                                               Количество
                                             end,
                                         'Детализация', case
                                                            when Количество is not null then
                                                                '0'
                                                            when число is not null then
                                                                '1'
                                             end) данные


              from (
                       select имя_таблицы,
                              дата,
                              имя_столбца,
                              статистика.данные_` + ИДСтатТаблицы + `.ид_спец_фильтра,
                          осп,
                          osp_name,
                          case
                              when статистика.столбцы.детализация = '[]' then
                                  статистика.данные_` + ИДСтатТаблицы + `.детали #>> '{"COUNT"}'
                              end Количество,
                          case
                              when статистика.столбцы.детализация <> '[]' then
                                  1
                              end число
                       FROM статистика.столбцы
                           JOIN статистика.данные_` + ИДСтатТаблицы + ` ON столбцы.ид_спец_фильтра::varchar = данные_` + ИДСтатТаблицы + `.ид_спец_фильтра::varchar
                           JOIN статистика.таблицы ON статистика.таблицы.ид = статистика.данные_` + ИДСтатТаблицы + `.ид_таблицы
                           JOIN fssp_configs.osp_address ON osp_address.osp_code = статистика.данные_` + ИДСтатТаблицы + `.осп
                       where дата = cast($1  as timestamp)
                   ) t
              group by имя_таблицы, t.осп, t.ид_спец_фильтра, t.osp_name, дата, t.имя_столбца, число, Количество
              ORDER BY osp_name
             ) s
        group by имя_таблицы, s.осп
    ) d
join (select
          jsonb_build_object (
										  столбцы.ид_таблицы,
										  jsonb_build_object(
												  'столбцы',jsonb_object_agg(ид_спец_фильтра,  имя_столбца),
												  'имя_таблицы', таблицы.имя_таблицы
											  )
									  ) таблица
							  from статистика.столбцы
									   join статистика.таблицы ON таблицы.ид = столбцы.ид_таблицы
							  where столбцы.ид_таблицы = $2 group by столбцы.ид_таблицы, таблицы.имя_таблицы) t on  1 = 1
						group by имя_таблицы, дата, t.таблица`,
					Values: [][]byte{
						//[]byte(ИДСтатТаблицы),
						[]byte(ВремяСтарта),
						[]byte(ИДСтатТаблицы),
					},
					DBSchema: ``,
				}.Выполнить(nil)
				if ОшибкаЗапроса != nil {
					Ошибка(" %+v ", ОшибкаЗапроса)
				}

				ДанныеСпецФильтров[ИдСпецФильтра] = РезультатЗапроса

				ДанныеДляРендераСИнфоКлиента := map[string]interface{}{
					"client":  client.UserInfo.Info,
					"data":    map[string]interface{}{"стат_таблица": РезультатЗапроса},
					"OspList": client.ПолучитьСписокОтделов(),
					"Osp":     ПолучитьСписокОСП(),
				}

				Инфо("ДанныеДляРендера %+v", ДанныеДляРендераСИнфоКлиента)
				HTML := string(render("ГенераторТаблицСДанными", ДанныеДляРендераСИнфоКлиента))

				СообщениеКлиенту := &Сообщение{
					Id:    0,
					От:    "io",
					Кому:  client.Login,
					Текст: "Осталось получить данные для " + strconv.Itoa(КоличествоЗапущенныхСпецФильтров) + " столбцов ",
					Контэнт: &ДанныеОтвета{
						Контейнер:     "article_content",
						Данные:        nil,
						HTML:          HTML,
						Обработчик:    "",
						СпособВставки: "обновить",
					},
				}
				client.Message <- СообщениеКлиенту
				КоличествоЗапущенныхСпецФильтров--

				if КоличествоЗапущенныхСпецФильтров > 0 {
					СообщениеКлиенту := &Сообщение{
						Id:          0,
						От:          "io",
						Кому:        client.Login,
						Текст:       "Осталось получить данные для " + strconv.Itoa(КоличествоЗапущенныхСпецФильтров) + " столбцов ",
						MessageType: []string{"attention"},
						Content: struct {
							Target     string      `json:"target"`
							Data       interface{} `json:"data"`
							Html       string      `json:"html"`
							Обработчик string      `json:"обработчик"`
						}{
							Target: "progress",
						},
					}
					client.Message <- СообщениеКлиенту
				}

				Инфо("КоличествоЗапущенныхСпецФильтров %+v", КоличествоЗапущенныхСпецФильтров)
			}
			Инфо("КоличествоЗапущенныхСпецФильтров %+v", КоличествоЗапущенныхСпецФильтров)
			if КоличествоЗапущенныхСпецФильтров == 0 {
				Инфо("КоличествоЗапущенныхСпецФильтров %+v закрываем канал", КоличествоЗапущенныхСпецФильтров)
				close(канал)
				break
			}
		}
	}

	Инфо("СпецФильтры %+v", СпецФильтры)
	Инфо("ДанныеСпецФильтров %+v", ДанныеСпецФильтров)

	return ДанныеСпецФильтров
}

func ОжиданиеДанных(ИДСтатТаблицы string, ВремяСтарта string, канал chan interface{}, завершено chan string) {
	сохранено := make(chan string)
	данные := <-канал

	Инфо("ОжиданиеДанных из ИДСтатТаблицы %+v", ИДСтатТаблицы)

	if данные != nil {
		Инфо("ОжиданиеДанныхИзАИС: Результат: %+v", данные)
		//ДанныеСпецФильтров := map[string]interface{}{}
		//for Имя, Данные := range данные.(map[string]interface{}){
		//	ДанныеСпецФильтров[Имя]=Данные
		//}

		go СохранитьДанныеСпецФильтров(ИДСтатТаблицы, данные, ВремяСтарта, сохранено)
		for {
			Инфо("ОжиданиеДанных  %+v", ИДСтатТаблицы)
			ИдСпецФильтра := <-сохранено
			if ИдСпецФильтра != "" {
				завершено <- ИдСпецФильтра
				//break
			}
		}
	}
	Инфо("выход из  ОжиданиеДанных %+v", ИДСтатТаблицы)
}

func СохранитьДанныеСпецФильтров(ИДСтатТаблицы string, ДанныеСпецФильтров interface{}, ВремяСтарта string, сохранено chan string) {
	//ВремяЗаписи := time.Now().Format("02.01.2006 15:04:05")
	Инфо("СохранитьДанныеСпецФильтров %+v")
	for ИдСпецФильтра, Данные := range ДанныеСпецФильтров.(map[string]map[string]РезультатSQLизАИС) {
		//Инфо("ИдСпецФильтра %+v Данные %+v", ИдСпецФильтра, Данные)

		СохранениеДанныхИзАИС := `INSERT INTO статистика.данные_` + ИДСтатТаблицы + ` (ид_таблицы, дата, ид_спец_фильтра, осп, детали) VALUES ($1,CAST($2 as timestamp),$3,$4,$5)`

		Строки := Данные["260"].МассивСтрок

		for _, Столбцы := range Строки {

			Детали, err := json.Marshal(Столбцы)
			if err != nil {
				Ошибка("Ошибка преобразования данных в json %+v  Данные %+v ", err, Данные)
			}

			//Инфо("Столбцы %+v", Столбцы)
			_, ОшибкаЗапроса := sqlStruct{
				Name: `Запись данных в таблицу ` + ИДСтатТаблицы,
				Sql:  СохранениеДанныхИзАИС,
				Values: [][]byte{
					[]byte(ИДСтатТаблицы),
					[]byte(ВремяСтарта),
					[]byte(ИдСпецФильтра),
					[]byte(Столбцы["OSP_CODE"].(string)),
					Детали,
				},
				DBSchema: `статистика`,
			}.Выполнить(nil)
			if ОшибкаЗапроса != nil {
				Ошибка(">>>> Ошибка SQL запроса: %+v \n\n", ОшибкаЗапроса)
			} else {
				//Инфо("РезультатЗапроса %+v", РезультатЗапроса)
			}

		}
		сохранено <- ИдСпецФильтра
	}

}

func ОбработатьДинамическийСкрипт(ДанныеЗапроса map[string]interface{}, Скрипт string, Данные map[string]interface{}) string {

	//Инфо("ДанныеЗапроса %+v %+v %+v", ДанныеЗапроса, ДанныеЗапроса["динамический"], reflect.TypeOf(ДанныеЗапроса["динамический"]))

	if Динамический := ДанныеЗапроса["динамический"]; Динамический.(string) == "t" {
		/* Если запрос динамический то соберём его*/
		if ДинамическийШаблон := ДанныеЗапроса["динамический_шаблон"]; ДинамическийШаблон != nil {
			Скрипт = ДинамическийШаблон.(string) + Скрипт
		}
		//Инфо("Скрипт.(string)  %+v", Скрипт, Данные)

		tpl, err := txtTpl.New("SqlЗапрос").Funcs(tplFunc()).Parse(Скрипт)
		if err != nil {
			Ошибка("err %+v tpl %+v ", err, tpl)
		}

		БайтБуферДанных := new(bytes.Buffer)
		//Инфо("Данные передаваемые в динамический sql %+v", Данные)
		err = tpl.Execute(БайтБуферДанных, Данные)
		if err != nil {
			Ошибка(" %+v ", err)
		} else {
			Скрипт = БайтБуферДанных.String()
			Скрипт = strings.TrimSpace(Скрипт)
		}
		//Инфо("Скрипт %+v", Скрипт)
		return Скрипт
	} else {
		return Скрипт
	}

}

func ВыполнитьСкрипт(client *Client, ДанныеОбработчка interface{}, ДанныеИзБд interface{}) map[string]interface{} {
	Результат := map[string]interface{}{}
	if НомерЗапроса := ДанныеОбработчка.(map[string]interface{})["запрос"]; НомерЗапроса != nil {
		ИДзапроса := strconv.Itoa(int(НомерЗапроса.(float64)))

		РезультатЗапроса, ОшибкаЗапроса := sqlStruct{
			Name: "Получить запрос для сохранения данных",
			Sql:  "SELECT * FROM iobot.запросы WHERE ид_запроса = $1",
			Values: [][]byte{
				[]byte(ИДзапроса),
			},
		}.Выполнить(nil)

		if ОшибкаЗапроса != nil {
			Ошибка("  %+v", ОшибкаЗапроса)
		}

		Инфо("  РезультатЗапроса %+v", РезультатЗапроса)
		Инфо("  ДанныеОбработчка %+v", ДанныеОбработчка)
		Инфо("  ДанныеИзБд %+v", ДанныеИзБд)
		//Инфо("  ДанныеИзБд %+v", reflect.TypeOf(ДанныеИзБд))
		var КартаСкрипта map[string]interface{}

		if len(РезультатЗапроса) == 1 {
			КартаСкрипта = РезультатЗапроса[0]
		}

		Инфо(" КартаСкрипта %+v", КартаСкрипта)
		Инфо("ДанныеИзБд тип %+v", reflect.TypeOf(ДанныеИзБд))

		//Аргументы := КартаСкрипта["аргументы"] // аргументы которые нужно получить из данных
		//БазаДанных := КартаСкрипта["база_данных"]
		//var SQLАргументы [][]byte
		//var АргументыSQL  [][]byte
		//var АргументыSQLдляАИС  []interface{}

		//Инфо(" %+v", Аргументы)

		switch ДанныеИзБд.(type) {
		case []interface{}:

		case map[string]interface{}:
		//Инфо("ДанныеИзБд reflect %+v",reflect.TypeOf(ДанныеИзБд) )
		case []map[string]interface{}:

			for _, СтрокаДанных := range ДанныеИзБд.([]map[string]interface{}) {

				var ОшибкаЗапроса error
				скрипт := ОбработатьДинамическийСкрипт(КартаСкрипта, КартаСкрипта["скрипт"].(string), СтрокаДанных)
				РезультатЗапросаИзАИС, ОшибкаЗапроса := sqlStruct{
					Name:            КартаСкрипта["имя"].(string),
					Sql:             скрипт,
					АргументыДляАИС: nil,
					БазаДанных:      "fssp",
					Клиент:          client,
				}.ВыполнитьЗапросВАИС()

				// Нужоно переделать чтобы функция была универсальная
				Результат = map[string]interface{}{
					КартаСкрипта["имя"].(string): РезультатЗапросаИзАИС[КартаСкрипта["имя"].(string)],
					"детали": ДанныеИзБд.([]map[string]interface{})[0]["детали"],
				}
				//ИменаПолей[КартаСкрипта["имя"].(string)] = РезультатЗапросаИзАИС[КартаСкрипта["имя"].(string)]
				//Результат["данные"] = append(ДанныеИзБд.([]map[string]interface{}), ИменаПолей)

				if ОшибкаЗапроса != nil {
					Ошибка(" %+v ", ОшибкаЗапроса)
				}

				Инфо("РезультатЗапросаИзАИС %+v", РезультатЗапросаИзАИС)
				//скрипт := ОбработатьДинамическийСкрипт(КартаСкрипта, КартаСкрипта["скрипт"].(string), АргументыSQLдляАИС)
				//Инфо("скрипт %+v", скрипт)

			}

		case []map[string]string:

		case map[string]map[string]РезультатSQLизАИС:
			return nil
		}
	}
	return Результат
}

/*
ДанныеИзБд или []map[string]string
			 или []map[string]interface
ид_запроса берёться из таблицы запросы столбец данные_обработчика
*/
func СохранитьВБД(client *Client, ДанныеОбработчка interface{}, ДанныеИзБд interface{}, ВходящиеДанные map[string]interface{}) map[string]interface{} {

	//Инфо("ДанныеИзБд %+v", ДанныеИзБд)
	//Инфо("ДанныеОбработчка %+v", ДанныеОбработчка)

	if НомерЗапроса := ДанныеОбработчка.(map[string]interface{})["запрос"]; НомерЗапроса != nil {
		ИДзапроса := strconv.Itoa(int(НомерЗапроса.(float64)))

		РезультатЗапроса, ОшибкаЗапроса := sqlStruct{
			Name: "Получить запрос для сохранения данных",
			Sql:  "SELECT * FROM iobot.запросы WHERE ид_запроса = $1",
			Values: [][]byte{
				[]byte(ИДзапроса),
			},
		}.Выполнить(nil)
		if ОшибкаЗапроса != nil {
			Ошибка("  %+v", ОшибкаЗапроса)
		}
		//Инфо("  РезультатЗапроса %+v", РезультатЗапроса)
		//Инфо("  ДанныеИзБд %+v", reflect.TypeOf(ДанныеИзБд))
		var КартаСкрипта map[string]interface{}
		if len(РезультатЗапроса) == 1 {
			КартаСкрипта = РезультатЗапроса[0]
		}

		if client != nil {
			СообщениеКлиенту := Сообщение{
				Id:          0,
				От:          "io",
				Кому:        client.Login,
				Текст:       КартаСкрипта["комментарий"].(string),
				MessageType: []string{"attention"},
				Content: struct {
					Target     string      `json:"target"`
					Data       interface{} `json:"data"`
					Html       string      `json:"html"`
					Обработчик string      `json:"обработчик"`
				}{
					Target: "progress",
				},
			}
			//Инфо("СообщениеКлиенту %+v\n", СообщениеКлиенту)
			СообщениеКлиенту.СохранитьИОтправить(client)
		}

		switch ДанныеИзБд.(type) {
		case []interface{}:
			ДанныеИзБд = ДанныеИзБд.([]interface{})

			for _, СтрокаДанных := range ДанныеИзБд.([]interface{}) {
				//Инфо("Строка %+v тип %+v", Строка,  reflect.TypeOf(Строка))

				Значения := ПолучитьSQLАргументы(КартаСкрипта["аргументы"], СтрокаДанных.(map[string]interface{}))

				скрипт := ОбработатьДинамическийСкрипт(КартаСкрипта, КартаСкрипта["скрипт"].(string), СтрокаДанных.(map[string]interface{}))
				//Инфо("Значения %+v скрипт %+v", Значения, КартаСкрипта["скрипт"].(string))
				РезультатЗапроса, ОшибкаЗапроса = sqlStruct{
					Name:   КартаСкрипта["имя"].(string),
					Sql:    скрипт,
					Values: Значения,
				}.Выполнить(nil)
			}

		case map[string]interface{}:
		//Инфо("ДанныеИзБд reflect %+v",reflect.TypeOf(ДанныеИзБд) )
		case []map[string]interface{}:
			ДанныеИзБд = ДанныеИзБд.([]map[string]interface{})

			for _, Строка := range ДанныеИзБд.([]map[string]interface{}) {
				Значения := ПолучитьSQLАргументы(КартаСкрипта["аргументы"], Строка)
				РезультатЗапроса, ОшибкаЗапроса = sqlStruct{
					Name:   КартаСкрипта["имя"].(string),
					Sql:    КартаСкрипта["скрипт"].(string),
					Values: Значения,
				}.Выполнить(nil)
			}

		case []map[string]string:
			ДанныеИзБд = ДанныеИзБд.([]map[string]string)

			for _, Строка := range ДанныеИзБд.([]map[string]string) {

				//Значения := ПолучитьSQLАргументы(КартаСкрипта["аргументы"], Строка)
				Значения := make([][]byte, len(КартаСкрипта["аргументы"].([]interface{})))

				for Номер, Имя := range КартаСкрипта["аргументы"].([]interface{}) {
					Значения[Номер] = []byte(Строка[Имя.(string)])
				}

				РезультатЗапроса, ОшибкаЗапроса = sqlStruct{
					Name:   КартаСкрипта["имя"].(string),
					Sql:    КартаСкрипта["скрипт"].(string),
					Values: Значения,
				}.Выполнить(nil)
			}
		case map[string]map[string]РезультатSQLизАИС:
			//Инфо("  ДанныеИзБд %+v", reflect.TypeOf(ДанныеИзБд))
			Данные := ДанныеИзБд.(map[string]map[string]РезультатSQLизАИС)
			for _, ДанныеЗапроса := range Данные {
				//Инфо("ИмяЗапроса %+v", ИмяЗапроса)
				for _, РезультатSQLизАИС := range ДанныеЗапроса {
					//Инфо("ОСП %+v", ОСП)
					//Инфо("РезультатSQLизАИС %+v", РезультатSQLизАИС)

					for _, Строка := range РезультатSQLизАИС.МассивСтрок {
						//Инфо("Строки %+v", Строка)

						//for _, Строка := range Строки {
						Инфо("Строка %+v", Строка)

						Значения := make([][]byte, len(КартаСкрипта["аргументы"].([]interface{})))
						Инфо("аргументы %+v ", КартаСкрипта["аргументы"])

						for Номер, Имя := range КартаСкрипта["аргументы"].([]interface{}) {
							//Инфо("Имя %+v", Имя)
							if strings.Contains(Имя.(string), "data.") {
								Значение := ""
								//Инфо("ВходящиеДанные %+v", ВходящиеДанные)
								if ВходящиеДанные["data"] != nil {
									data := strings.Split(Имя.(string), ".")
									Значение = data[1]
									Значения[Номер] = []byte(ВходящиеДанные["data"].(map[string]interface{})[Значение].(string))
								} else {
									Ошибка("нет даных в data  Имя %+v ВходящиеДанные %+v ", Имя, ВходящиеДанные)
								}

							} else {
								//Инфо("Имя %+v", Имя)
								if Строка[Имя.(string)] != nil {
									Значения[Номер] = []byte(Строка[Имя.(string)].(string))
								} else {
									Ошибка("нет даных в Строка  Имя %+v КартаСкрипта[\"аргументы\"] %+v ", Имя, КартаСкрипта["аргументы"])
								}

							}
							//Значения[Номер] = []byte(Строка[Имя.(string)].(string))
							//Инфо("Строка[%+v] %+v",Имя.(string), Строка[Имя.(string)])
						}
						Инфо("Значения %+v", Значения)

						РезультатЗапроса, ОшибкаЗапроса = sqlStruct{
							Name:   КартаСкрипта["имя"].(string),
							Sql:    КартаСкрипта["скрипт"].(string),
							Values: Значения,
						}.Выполнить(nil)

						//}
					}
				}
			}

		}
		if client != nil {
			СообщениеКлиенту := Сообщение{
				Id:          0,
				От:          "io",
				Кому:        client.Login,
				Текст:       "Завершаю: " + КартаСкрипта["комментарий"].(string),
				MessageType: []string{"attention"},
				Content: struct {
					Target     string      `json:"target"`
					Data       interface{} `json:"data"`
					Html       string      `json:"html"`
					Обработчик string      `json:"обработчик"`
				}{
					Target: "progress",
				},
			}
			//Инфо("СообщениеКлиенту %+v\n", СообщениеКлиенту)
			СообщениеКлиенту.СохранитьИОтправить(client)
		}
	}

	Инфо(" Конец %+v", "СохранитьВБД")
	return nil
}

/*
ДанныеИзБд могуть быть как из бд IO так и  из аиса тоесть либо []map[string]interface{} либо map[string]РезультатSQLизАИС

*/

func ОбработатьДанные(ИмяФункции string, ДанныеОбработчка interface{}, client *Client, ДанныеИзБд interface{}, ВходящиеДанные map[string]interface{}) map[string]interface{} {
	Инфо("ОбработатьДанные ИмяФункции %+v \n", ИмяФункции)

	if _, ЕстьДействие := Действия[ИмяФункции]; !ЕстьДействие {
		Инфо("  %+v ИмяФункции  %+v", ЕстьДействие, Действия)
		return nil
	}
	return Действия[ИмяФункции].(func(*Client, interface{}, interface{}, map[string]interface{}) map[string]interface{})(client, ДанныеОбработчка, ДанныеИзБд, ВходящиеДанные)
}

func Выполнить(ИмяФункции string, client *Client, mes *Сообщение) map[string]interface{} {
	Инфо("Выполнить ИмяФункции %+v \n", ИмяФункции)

	if _, ЕстьДействие := Действия[ИмяФункции]; !ЕстьДействие {
		Инфо("  %+v Действия  %+v", ЕстьДействие, Действия)
		return nil
	}

	//Инфо("Выполнить client %+v\n", client)
	//Инфо("Выполнить mes %+v\n", mes)
	//Инфо("Выполнить Действия[ИмяФункции] %+v\n", Действия[ИмяФункции])

	return Действия[ИмяФункции].(func(*Client, Сообщение) map[string]interface{})(client, *mes)
}

func (client *Client) ПроверитьЛогин(mes Сообщение) map[string]interface{} {
	Инфо(">>>>> ПроверитьЛогин mes %+v\n", mes.ВходящиеАргументы)
	Результат := map[string]interface{}{}
	login, ЕстьЛогин := mes.ВходящиеАргументы["login"]
	if !ЕстьЛогин {
		Результат["Обработчик"] = "ЛогинНеНайден"
		return Результат
	}

	FIO, errFio := sqlStruct{
		Name: "статичные_ip",
		Sql:  "SELECT second_name,givenname,initials, login FROM fssp_configs.users WHERE login = $1",
		Values: [][]byte{
			[]byte(login.(string)),
		},
	}.Выполнить(nil)

	if errFio != nil {
		Инфо(">>>> ERROR \n %+v \n\n", errFio)
		Результат["Обработчик"] = "ЛогинНеНайден"
	} else {
		if len(FIO) > 0 {
			ФИО := FIO[0]
			Результат["Обработчик"] = "ПоказатьФИОВФормеАтворизации"
			Результат["Данные"] = ФИО["second_name"].(string) + " " + ФИО["givenname"].(string) + " " + ФИО["initials"].(string)
		}
	}

	return Результат
}

func (client *Client) СохранитьЛог(skillId string, logCmd string, errors []string) {
	errorsBytes, err := json.Marshal(errors)
	if err != nil {
		Инфо("err	 %+v\n", err)
	}
	_, err = sqlStruct{
		Name: "io_action_log",
		Sql:  `INSERT INTO io_action_log (login, ip, action_id, action_error, action_out) VALUES($1,$2,$3,$4,$5)`,
		Values: [][]byte{
			[]byte(client.Login),
			[]byte(client.Ip),
			[]byte(skillId),
			errorsBytes,
			[]byte(logCmd),
		},
	}.Выполнить(nil)
	if err != nil {
		Инфо(">>>> Ошибка SQL запроса: %+v \n\n", err)
	}

}

type BotMenuStruct struct {
	Id          int                    `json:"id"`
	Name        string                 `json:"name"`
	Description string                 `json:"description"`
	Problem     []string               `json:"problem"`
	Actions     map[string]interface{} `json:"actions"`
	Tags        []string               `json:"groups"`
}

func (client *Client) ПолучитьМенюКуратора() []map[string]interface{} { // []BotMenuStruct
	if client.UserInfo != nil && client.UserInfo.Info.OspCode == 26911 {
		return client.ПолучитьМенюБота()
	}
	return nil
}

func (client *Client) ПолучитьБыстрыеДиалоги() []map[string]interface{} {
	SQLString := `SELECT * FROM iobot.диалоги_ио WHERE показывать_в_меню = true and доступен = true`
	if client.UserInfo != nil && client.UserInfo.Info.OspCode != 26911 {
		SQLString = `SELECT * FROM iobot.диалоги_ио WHERE показывать_в_меню = true`
	}
	if client.UserInfo != nil && client.UserInfo.Info.Login == "maksimchuk@r26" {
		SQLString = `SELECT * FROM iobot.диалоги_ио`
	}

	ПолучитьДиалоги, err := sqlStruct{
		Name: `io_actions`,
		Sql:  SQLString,
	}.Выполнить(nil)
	if err != nil {
		Инфо(">>>> ERROR \n %+v \n\n", err)
	}
	return ПолучитьДиалоги
}

func (client *Client) ПолучитьМенюБота() []map[string]interface{} { // []BotMenuStruct
	SQLString := `SELECT * FROM io_actions WHERE delete = false`
	//Инфо("ПолучитьМенюБота %+v", ПолучитьМенюБота)
	//Инфо("client %+v\n", &client.UserInfo)
	//sss := *client.UserInfo
	//Инфо("client Info %+v\n", *sss.Info)

	if client.UserInfo != nil && client.UserInfo.Info.OspCode != 26911 {
		SQLString = `SELECT * FROM iobot.io_actions WHERE self_use = true and delete = false`
	}

	BotMenuMap, err := sqlStruct{
		Name: `io_actions`,
		Sql:  SQLString,
	}.Выполнить(nil)
	//Инфо("BotMenuMap %+v\n",BotMenuMap )
	if err != nil {
		Ошибка(">>>> ERROR \n %+v \n\n", err)
	}

	//Инфо("BotMenu %+v\n", BotMenuMap)
	//Инфо("BotMenuMap %+v\n", BotMenuMap)
	return BotMenuMap
}

func ВыполнитьСкриптДляКаждогоЗначения(client *Client, ДанныеОбработчка interface{}, ДанныеИзБд interface{}, ВходящиеДанные map[string]interface{}) map[string]interface{} {

	//началоСбора := Сегодня()
	//Инфо("ДанныеОбработчка %+v", ДанныеОбработчка)
	//Инфо("ДанныеИзБд %+v", ДанныеИзБд)
	//Инфо("ВходящиеДанные %+v", ВходящиеДанные)
	КоличествоГорутин := 0
	var ВсеДанные map[string]map[string]map[string]РезультатSQLизАИС
	var РезультатВсеДанные map[string]interface{}
	if НомерЗапроса := ДанныеОбработчка.(map[string]interface{})["запрос"]; НомерЗапроса != nil {
		ИДзапроса := strconv.Itoa(int(НомерЗапроса.(float64)))

		Скрипт, ОшибкаЗапроса := sqlStruct{
			Name: "Получить запрос для сохранения данных",
			Sql:  "SELECT * FROM iobot.запросы WHERE ид_запроса = $1",
			Values: [][]byte{
				[]byte(ИДзапроса),
			},
		}.Выполнить(nil)

		if ОшибкаЗапроса != nil {
			Ошибка("  %+v", ОшибкаЗапроса)
		}
		КартаСкрипта := Скрипт[0]
		РезультатВсеДанные = map[string]interface{}{
			КартаСкрипта["имя"].(string): nil,
		}

		ВсеДанные = map[string]map[string]map[string]РезультатSQLизАИС{
			КартаСкрипта["имя"].(string): {},
		}

		Инфо("ДанныеИзБд %+v", reflect.TypeOf(ДанныеИзБд))
		ДанныеИзАис := map[string]map[string]РезультатSQLизАИС{}

		РезультатЗапроса := make(chan map[string]РезультатSQLизАИС, 100)

		switch ДанныеИзБд.(type) {
		case []interface{}:

		case map[string]map[string]РезультатSQLизАИС:
			ДанныеИзАис = ДанныеИзБд.(map[string]map[string]РезультатSQLизАИС)

		}
		//var РезультатЗапроса chan map[string]РезультатSQLизАИС

		//for осп, данные := range ДанныеИзБд {}
		for ИмяСкрипта, ДанныеЗапроса := range ДанныеИзАис {

			Инфо("ИмяСкрипта %+v", ИмяСкрипта)

			for осп, Строки := range ДанныеЗапроса {

				//Инфо("осп %+v", осп)
				ДанныеПокдлюченияОСП, ОшибкаЗапроса := sqlStruct{
					Name:   "Данные подключений к ОСП",
					Sql:    "SELECT * FROM fssp_configs.osp_address WHERE osp_code = $1",
					Клиент: client,
					Values: [][]byte{
						[]byte(осп),
					},
				}.Выполнить(nil)
				if ОшибкаЗапроса != nil {
					Ошибка(" %+v ", ОшибкаЗапроса)
				}
				//Инфо("ДанныеПокдлюченияОСП %+v", ДанныеПокдлюченияОСП)

				conn := OSPconnect(ДанныеПокдлюченияОСП[0]["pwd"].(string), ДанныеПокдлюченияОСП[0]["ip_ais"].(string))

				ДанныеПодключения := ДанныеПокдлюченияОСП[0]
				//Инфо("КартаСкрипта %+v аргументы %+v", КартаСкрипта, reflect.TypeOf(КартаСкрипта["аргументы"]))

				for _, Строка := range Строки.МассивСтрок {

					if client != nil {
						СообщениеКлиенту := Сообщение{
							Id:          0,
							От:          "io",
							Кому:        client.Login,
							Текст:       "Запрашиваю данные в " + ДанныеПодключения["osp_name"].(string) + " для КБК " + Строка["KBK"].(string),
							MessageType: []string{"attention"},
							Content: struct {
								Target     string      `json:"target"`
								Data       interface{} `json:"data"`
								Html       string      `json:"html"`
								Обработчик string      `json:"обработчик"`
							}{
								Target: "progress",
							},
						}

						СообщениеКлиенту.СохранитьИОтправить(client)
					}
					//Инфо("Строка %+v", Строка)
					sqlData := sqlStruct{
						Name: Строка["KBK"].(string),
						Sql:  КартаСкрипта["скрипт"].(string),
						//SQLАргументы:    КартаСкрипта["аргументы"].([]interface{}),
						Клиент:            client,
						Conn:              conn,
						ДанныеПодключения: ДанныеПодключения,
						ВходящиеАргументы: ВходящиеДанные,
						АргументыДляАИС: []interface{}{
							ВходящиеДанные["data"].(map[string]interface{})["дата_с"],
							ВходящиеДанные["data"].(map[string]interface{})["дата_по"],
							Строка["KBK"],
						},
					}
					КоличествоГорутин++
					go sqlData.ВыполнитьSQLАИС(РезультатЗапроса)
				}
			}
		}

		//if sqlData.Клиент != nil{
		//	СообщениеКлиенту := Сообщение{
		//		Id:      0,
		//		От:      "io",
		//		Кому:    sqlData.Клиент.Login,
		//		Текст:   "Запрашиваю данные в "+ДанныеПокдлюченияОСП["osp_name"].(string),
		//		MessageType: []string{"attention"},
		//		Content: struct {
		//			Target string `json:"target"`
		//			Data interface{} `json:"data"`
		//			Html string `json:"html"`
		//			Обработчик string `json:"обработчик"`
		//		}{
		//			Target:"progress",
		//		},
		//	}
		//	Инфо("СообщениеКлиенту %+v\n", СообщениеКлиенту)
		//	СообщениеКлиенту.СохранитьИОтправить(sqlData.Клиент)
		//}
		//if sqlData.ПеребратьАргументы != nil {
		//
		//}

		//		IP_NUMBER номер_ип
		//		ID_NUMBER номер_ид
		//		DBTR_NAME должник
		//		BEGIN_DT_REST начисленно_взыскать_на_начало
		//END_DT_REST начислено_взыскать_на_конец
		//		IP_EXEC_PRIST_NAME спи_ведущий
		//		IP_STATUS статус_ип

		for КоличествоГорутин > 0 {
			Результат := <-РезультатЗапроса
			if Результат != nil {
				var ОСП string
				var ИмяОсп string
				//Инфо(" ДанныеИзАис КБК %+v", Результат)

				for _, данные := range Результат {
					ОСП = strconv.Itoa(данные.ОСП["osp_code"].(int))
					ИмяОсп = данные.ОСП["osp_name"].(string)

				}

				//if ОСПкод := Результат[КартаСкрипта["имя"].(string)].ОСП["osp_code"];ОСПкод != nil{
				//	ОСП = strconv.Itoa(ОСПкод.(int))
				//} else {
				//	ОСП = "ФССП"
				//}

				ВсеДанные[КартаСкрипта["имя"].(string)][ОСП] = Результат

				go func(client *Client) {
					for КБК, Строки := range Результат {
						if client != nil {
							СообщениеКлиенту := Сообщение{
								Id:          0,
								От:          "io",
								Кому:        client.Login,
								Текст:       "Сохраняю полученные данные " + ИмяОсп + " для КБК " + КБК + ". Количество полученых строк: " + strconv.Itoa(len(Строки.МассивСтрок)),
								MessageType: []string{"attention"},
								Content: struct {
									Target     string      `json:"target"`
									Data       interface{} `json:"data"`
									Html       string      `json:"html"`
									Обработчик string      `json:"обработчик"`
								}{
									Target: "progress",
								},
							}

							СообщениеКлиенту.СохранитьИОтправить(client)
						}
						if len(Строки.МассивСтрок) > 0 {
							sql := `INSERT INTO статистика.административные_минуса (номер_ип, номер_ид, должник, начисленно_взыскать_на_начало, начислено_взыскать_на_конец, спи_ведущий, статус_ип, кбк, осп, начало_периода, конец_периода,дата_отчёта ) VALUES `
							//ВходящиеДанные["data"].(map[string]interface{})["дата_с"],
							//	ВходящиеДанные["data"].(map[string]interface{})["дата_по"],
							значения := ""

							for номер, Строка := range Строки.МассивСтрок {
								значения = значения + "(" + "'" + Строка["IP_NUMBER"].(string) + "'" + "," + "'" + Строка["ID_NUMBER"].(string) + "'" + "," + "'" + Строка["DBTR_NAME"].(string) + "'" + "," + Строка["BEGIN_DT_REST"].(string) + "," + Строка["END_DT_REST"].(string) + "," + "'" + Строка["IP_EXEC_PRIST_NAME"].(string) + "'" + "," + "'" + Строка["IP_STATUS"].(string) + "'" + "," + "'" + КБК + "'" + "," + ОСП + ",cast('" + ВходящиеДанные["data"].(map[string]interface{})["дата_с"].(string) + "' as date),cast('" + ВходящиеДанные["data"].(map[string]interface{})["дата_по"].(string) + "' as date)," + "cast('" + ВходящиеДанные["data"].(map[string]interface{})["время"].(string) + "' as timestamp)" + ")"
								if номер < len(Строки.МассивСтрок)-1 {
									значения = значения + ","
								}
							}

							sql = sql + значения

							_, ОшибкаЗапроса := sqlStruct{
								Name: КартаСкрипта["имя"].(string),
								Sql:  sql,
							}.Выполнить(nil)

							if ОшибкаЗапроса != nil {
								Ошибка(" %+v ", ОшибкаЗапроса)
							}
							//Инфо("РезультатСоxранения %+v", РезультатСоxранения)
						}
					}
				}(client)
				//КэшироватьДанные(sqlData.Name, *sqlData.Клиент, Результат, Результат[sqlData.Name].ОСП["osp_name"].(string))
				КоличествоГорутин--
				//if client != nil{
				//	СообщениеКлиенту := Сообщение{
				//		Id:      0,
				//		От:      "io",
				//		Кому:   client.Login,
				//		Текст:   "Осталось получить ещё из "+strconv.Itoa(КоличествоГорутин) + " ОСП",
				//		MessageType: []string{"attention"},
				//		Content: struct {
				//			Target string `json:"target"`
				//			Data interface{} `json:"data"`
				//			Html string `json:"html"`
				//			Обработчик string `json:"обработчик"`
				//		}{
				//			Target:"progress",
				//		},
				//	}
				//	Инфо("СообщениеКлиенту %+v\n", СообщениеКлиенту)
				//	go СообщениеКлиенту.СохранитьИОтправить(client)
				//}
			}
			if КоличествоГорутин == 0 {
				if client != nil {
					СообщениеКлиенту := Сообщение{
						Id:          0,
						От:          "io",
						Кому:        client.Login,
						Текст:       "Данные по минусовым строкам собраны, начинаю собирать Безнадёжные к взысканию",
						MessageType: []string{"attention"},
						Content: struct {
							Target     string      `json:"target"`
							Data       interface{} `json:"data"`
							Html       string      `json:"html"`
							Обработчик string      `json:"обработчик"`
						}{
							Target: "progress",
						},
					}
					//Инфо("СообщениеКлиенту %+v\n", СообщениеКлиенту)
					go СообщениеКлиенту.СохранитьИОтправить(client)
				}
				break
			}
		}
		РезультатВсеДанные[КартаСкрипта["имя"].(string)] = ВсеДанные[КартаСкрипта["имя"].(string)]
	}
	Инфо("конец ВыполнитьСкриптДляКаждогоЗначения %+v")
	return РезультатВсеДанные
}

func ОбработатьСтатОтчёт(client *Client, ДанныеОбработчка interface{}, ДанныеИзБд interface{}, ВходящиеДанные map[string]interface{}) map[string]interface{} {

	ДанныеПоОтчётам := ДанныеИзБд.(map[string]map[string]РезультатSQLизАИС)

	Результат := map[string]map[string]map[string]string{} // осп кодФормы раздел значение

	ВсеОтчёты := map[string]interface{}{}

	for код, данные := range ДанныеПоОтчётам {
		Инфо("код %+v", код)

		for кодДанных, Строки := range данные {
			Инфо("кодДанных %+v", кодДанных)
			if ВсеОтчёты[код] == nil {
				ВсеОтчёты[код] = map[string]map[string]map[string]string{}
			}

			//Инфо("  Строки.МассивСтрок %+v", Строки.МассивСтрок)
			for _, Строка := range Строки.МассивСтрок {
				Отчёт := Строка["REPORT_BLOB"].(string)
				ОСП := "260" + Строка["DEPARTMENT"].(string)

				Инфо("ОСП %+v %+v", ОСП, Строка["ID"].(string))

				ДанныеОтчёта := ПолучитьЗначенияИзОтчета(Отчёт, Строка["STAT_FORM_CODE"].(string))

				if ДанныеОтчёта == nil {
					continue
				}
				if Результат[ОСП] == nil {

					for КодФормы, Значения := range ДанныеОтчёта {
						Результат[ОСП] = map[string]map[string]string{
							КодФормы: Значения,
						}
					}
				} else {
					for КодФормы, Значения := range ДанныеОтчёта {
						Результат[ОСП][КодФормы] = Значения
						//Результат[ОСП] = map[string]map[string]string{
						//	КодФормы: Значения,
						//}
					}
				}

			}
			ВсеОтчёты[код] = Результат
		}

	}
	Инфо("ВсеОтчёты %+v", ВсеОтчёты)
	return ВсеОтчёты

}

func ПолучитьЗначенияИзОтчета(Отчёт string, КодФормы string) map[string]map[string]string {
	odsFile, err := ods.NewReader(bytes.NewReader([]byte(Отчёт)), int64(len([]byte(Отчёт))))
	//КодФормы := Результат[0][1]
	if err != nil {
		Ошибка(" %+v ", err, Отчёт, КодФормы)
		return nil
	}
	var docOds ods.Doc
	err = odsFile.ParseContent(&docOds)
	if err != nil {
		Ошибка(" %+v ", err)
	}

	координатыЗначений := map[string]map[string][]int{
		"011": {
			"1.1.1":  []int{1, 1, 1},
			"1.2.1":  []int{1, 2, 1},
			"1.4.1":  []int{1, 4, 1},
			"1.5.1":  []int{1, 5, 1},
			"2.1.13": []int{2, 1, 13},
			"2.2.13": []int{2, 2, 13},
			"2.4.13": []int{2, 4, 13},
		},
		"501": {
			"1.18.1":  []int{1, 18, 1},
			"5.15.15": []int{5, 15, 15},
			"5.15.16": []int{5, 15, 16},
		},
		"013": {
			"1.4.1":  []int{1, 4, 1},
			"1.13.1": []int{1, 13, 1},
			"1.14.1": []int{1, 14, 1},
			"2.4.1":  []int{2, 4, 1},
			"2.13.1": []int{2, 13, 1},
			"2.14.1": []int{2, 14, 1},
			"3.12.1": []int{3, 12, 1},
			"3.16.1": []int{3, 16, 1},
			"3.22.1": []int{3, 22, 1},
			"3.23.1": []int{3, 23, 1},
			"3.24.1": []int{3, 24, 1},
			"3.25.1": []int{3, 25, 1},
			"3.26.1": []int{3, 26, 1},
			"3.27.1": []int{3, 27, 1},
			"3.30.1": []int{3, 30, 1},
			"5.8.1":  []int{5, 8, 1},
			"5.10.1": []int{5, 10, 1},
			"5.11.1": []int{5, 11, 1},
		},
	}
	Данные := ПройтиПОТаблице(docOds, КодФормы, координатыЗначений[КодФормы])

	return Данные
}

type ДанныеТаблиц struct {
	Раздел      int
	Заголовок   map[string]int
	НомераСтрок map[int]int
	Строки      map[int]map[int]string
}

func ПройтиПОТаблице(docOds ods.Doc, КодФормы string, Коорд map[string][]int) map[string]map[string]string {
	Инфо(" %+v  %+v", КодФормы, Коорд)
	Таблицы := map[int]ДанныеТаблиц{}

	Раздел := 0

	for _, t := range docOds.Table {
		//Инфо("Таблица № %+v имя %+v", Раздел, t.Name)
		if !strings.Contains(strings.ToUpper(t.Name), "РАЗДЕЛ") {
			continue
		}
		//Раздел++
		//Инфо("Таблица № %+v имя %+v", Раздел, t.Name)
		КоличествоЗначимыхЯчеекВстроке := 0
		Заголовок := map[string]int{}
		НомераСтрок := map[int]int{}
		Строки := map[int]map[int]string{}

		for номерСтроки, r := range t.Row {
			Строки[номерСтроки] = map[int]string{}
			Строка := []string{}
			НомерЯчейкиВСтроке := 0
			СтрокаЗаголовка := false

			for номерЯчейки, rc := range r.Cell {
				if номерЯчейки == 0 && номерСтроки == 0 {
					КоличествоЗначимыхЯчеекВстроке = rc.ColSpan
				}
				//Инфо(" %+v", rc.RepeatedCols)

				значениеЯчейки := ""

				if rc.RepeatedCols > 0 && rc.RepeatedCols <= КоличествоЗначимыхЯчеекВстроке {
					//Инфо("rc %+v", rc)

					for i := 1; i <= rc.RepeatedCols; i++ {
						if rc.Value != "" {
							значениеЯчейки = rc.Value
						} else if len(rc.P) > 0 {
							значениеЯчейки = rc.P[0].XML
						} else {
							значениеЯчейки = "_"
							Строка = append(Строка, "_")
						}
						НомерЯчейкиВСтроке++

						if strings.Contains(strings.ToUpper(значениеЯчейки), "РАЗДЕЛ ") {
							ЗаголовокРаздела := strings.Split(значениеЯчейки, " ")
							//Инфо("ЗаголовокРаздела %+v", ЗаголовокРаздела)
							//Инфо("ЗаголовокРаздела[1] %+v", ЗаголовокРаздела[1])
							НомерРаздела := strings.Replace(ЗаголовокРаздела[1], ".", "", -1)

							НовыйРаздел, err := strconv.Atoi(НомерРаздела)
							if err != nil {
								Ошибка(" %+v  %+v ", err, err)
							}
							//Инфо("Раздел %+v НовыйРаздел  %+v", Раздел, НовыйРаздел)
							if Раздел != НовыйРаздел && Раздел != 0 {
								if _, ok := Таблицы[Раздел]; !ok {
									Таблицы[Раздел] = ДанныеТаблиц{
										Раздел:      Раздел,
										Заголовок:   Заголовок,
										НомераСтрок: НомераСтрок,
										Строки:      Строки,
									}
								}

							}
							Раздел = НовыйРаздел
							Заголовок = map[string]int{}
							НомераСтрок = map[int]int{}
							Строки[номерСтроки] = map[int]string{}
							СтрокаЗаголовка = false
						}

						if значениеЯчейки == "А" {
							СтрокаЗаголовка = true
						}
						if СтрокаЗаголовка == true {
							Заголовок[значениеЯчейки] = НомерЯчейкиВСтроке
						} else {
							if НомерЯчейкиВСтроке == Заголовок["Б"] {
								номер, _ := strconv.Atoi(значениеЯчейки)
								НомераСтрок[номер] = номерСтроки
							}
							Строки[номерСтроки][НомерЯчейкиВСтроке] = значениеЯчейки
							Строка = append(Строка, значениеЯчейки)
						}

					}
				} else {
					if rc.Value != "" {
						значениеЯчейки = rc.Value
					} else if len(rc.P) > 0 {
						значениеЯчейки = rc.P[0].XML
					} else {
						значениеЯчейки = "_"
						Строка = append(Строка, "_")
					}
					НомерЯчейкиВСтроке++

					if strings.Contains(strings.ToUpper(значениеЯчейки), "РАЗДЕЛ ") {
						ЗаголовокРаздела := strings.Split(значениеЯчейки, " ")

						//Инфо("ЗаголовокРаздела %+v", ЗаголовокРаздела)
						//Инфо("ЗаголовокРаздела[1] %+v", ЗаголовокРаздела[1])

						НомерРаздела := strings.Replace(ЗаголовокРаздела[1], ".", "", -1)

						НовыйРаздел, err := strconv.Atoi(НомерРаздела)

						if err != nil {
							Ошибка("err %+v значениеЯчейки %+v ", err, значениеЯчейки)
						}
						//Инфо("Раздел %+v НовыйРаздел  %+v", Раздел, НовыйРаздел)

						if Раздел != НовыйРаздел && Раздел != 0 {
							if _, ok := Таблицы[Раздел]; !ok {
								Таблицы[Раздел] = ДанныеТаблиц{
									Раздел:      Раздел,
									Заголовок:   Заголовок,
									НомераСтрок: НомераСтрок,
									Строки:      Строки,
								}
							}

						}
						Раздел = НовыйРаздел
						Заголовок = map[string]int{}
						НомераСтрок = map[int]int{}
						Строки[номерСтроки] = map[int]string{}
						СтрокаЗаголовка = false
					}

					if значениеЯчейки == "А" {
						СтрокаЗаголовка = true
					}
					if СтрокаЗаголовка == true {
						Заголовок[значениеЯчейки] = НомерЯчейкиВСтроке
					} else {
						if НомерЯчейкиВСтроке == Заголовок["Б"] {
							номер, _ := strconv.Atoi(значениеЯчейки)
							НомераСтрок[номер] = номерСтроки
						}
						Строки[номерСтроки][НомерЯчейкиВСтроке] = значениеЯчейки
						Строка = append(Строка, значениеЯчейки)
					}
					//if КодФормы == "011" && Раздел == 1 {
					//	Инфо("Раздел %+v", Раздел)
					//	Инфо("Заголовок %+v", Заголовок)
					//	Инфо("НомераСтрок %+v", НомераСтрок)
					//	Инфо("Строки %+v", Строки)
					//}

				}

			}

		}
		//if КодФормы == "011" && Раздел == 1 {
		//	Инфо("Таблицы 1 %+v", Таблицы)
		//}
		Таблицы[Раздел] = ДанныеТаблиц{
			Раздел:      Раздел,
			Заголовок:   Заголовок,
			НомераСтрок: НомераСтрок,
			Строки:      Строки,
		}
		//if КодФормы == "011" && Раздел == 1 {
		//	Инфо("Таблицы 2 %+v", Таблицы)
		//}

		//Инфо("КодФормы, Строки %+v",КодФормы, Строки)
	}

	Результат := map[string]string{}

	//if КодФормы == "501" {
	//	Инфо("Таблицы 501 %+v", Таблицы)
	//	Инфо("Коорд %+v", Коорд)
	//}
	//Инфо("Таблицы %+v", Таблицы)

	if КодФормы == "011" {
		Инфо("011 Таблицы %+v", Таблицы)
		Инфо(" %+v", Таблицы[2].Заголовок)
	}

	for ячейка, коорд := range Коорд {
		//Инфо("Коорд %+v", Коорд)
		ТаблицаДанных := Таблицы[коорд[0]]

		НомерСтроки := ТаблицаДанных.НомераСтрок[коорд[1]]
		НомерЯчейки := ТаблицаДанных.Заголовок[strconv.Itoa(коорд[2])]

		//Инфо("НомерСтроки %+v", ТаблицаДанных.НомераСтрок)
		//Инфо("НомерЯчейки %+v", ТаблицаДанных.Заголовок)

		ЗначениеЯчейки := ТаблицаДанных.Строки[НомерСтроки][НомерЯчейки]
		if коорд[2] == 13 {
			Инфо("НомерСтроки %+v Данные  %+v ", НомерСтроки, ТаблицаДанных.Строки[НомерСтроки])
			Инфо("НомерЯчейки  %+v ", НомерЯчейки)
			Инфо("ЗначениеЯчейки  %+v ", ЗначениеЯчейки)

		}

		//Инфо("ТаблицаДанных.Строки[НомерСтроки] %+v НомерЯчейки %+v", ТаблицаДанных.Строки[НомерСтроки], НомерЯчейки)
		Результат[ячейка] = ЗначениеЯчейки
	}
	//Инфо("КодФормы %+v Результат %+v", КодФормы, Результат)
	//}
	return map[string]map[string]string{
		КодФормы: Результат,
	}
}
